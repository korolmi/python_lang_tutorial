
== Неформальное введение в Python ==

В приведенных далее примерах, ввод и вывод различаются присутствием и отсутствием приглашений соответственно (приглашениями являются <tt>>>></tt> и <tt>...</tt>): чтобы воспроизвести пример — вам нужно ввести всё, что следует за приглашением, после его появления; строки, не начинающиеся с приглашений являются выводом интерпретатора. Обратите внимание, что строка, в которой содержится лишь вспомогательное приглашение («<tt>... </tt>») означает, что вам нужно ввести пустую строку — этот способ используется для завершения многострочных команд.

Большинство примеров в этом руководстве — даже те, которые вводятся в интерактивном режиме — содержат комментарии. Комментарии в Python начинаются с символа решетки # (<tt>hash</tt>) — и продолжаются до физического конца строки. Комментарии могут находиться как в начале строки, так и следовать за пробельными символами или кодом — но не содержаться внутри строки. Символ решётки в строке остаётся лишь символом решётки. Поскольку комментарии предназначены для того, чтобы сделать код более понятным, и не интерпретируются Python — при вводе примеров они могут быть опущены.

Несколько примеров:

<syntaxhighlight lang="python"># это первый комментарий
spam = 1                 # а это второй комментарий
                         # ... и наконец третий!
text = "# Это не комментарий, потому что он - внутри кавычек."</syntaxhighlight>

=== Использование Python в качестве калькулятора ===

Давайте опробуем несколько простых команд Python. Запустите интерпретатор и дождитесь появления основного приглашения — <tt>>>></tt>. (Это не должно занять много времени.)

==== Числа ====

Поведение интерпретатора сходно поведению калькулятора: вы вводите выражение, а в ответ он выводит значение. Синтаксис выражений привычен: операции <code>+</code>, <code>-</code>, <code>*</code> и <code>/</code> работают так же как и в большинстве других языков (например, Паскале или C); для группировки можно использовать скобки. Например:

<syntaxhighlight lang="python">>>> 2+2
4
>>> 50-5*6
20
>>> (50-5*6)/4
5.0
>>> 8/5 # При делении целых чисел всегда получаются дробное число
1.6
</syntaxhighlight>

Целые числа (например, 2, 4, 20) имеют тип int, числа с дробной частью (например, 5.0, 1.6) имеют тип float. Мы познакомимся более подробно с числовыми типами данных позже в учебнике.

Деление (<code>/</code>) всегда возвращает число с плавающей точкой (<code>float</code>). Для получения целого результата при делении целых чисел с отсечением дробной части, предназначена другая операция: <code>//</code>, для получения остатка от деления - <code>%</code>:

<syntaxhighlight lang="python">>>> 17 / 3 # просто деление целых возвращает плавающее
5.6666666666667
>>> 17 // 3 # деление с отсечением отбросит дробную часть
5
>>> 7 % 3 # оператор получения остатка вернет остаток
2
>>> 5 * 3 + 2 # результат * делитель + остаток
17</syntaxhighlight>

В Python существует оператор <code>**</code> - он возводит в степень:

<syntaxhighlight lang="python">>>> 5 ** 2 # 5 в квадрате
25
>>> 2 ** 7 # 2 в степени 7
128</syntaxhighlight>

Знак равенства (<code>'='</code>) используется для присваивания переменной какого-либо значения. После этого действия в интерактивном режиме ничего не выводится:

<syntaxhighlight lang="python">>>> width = 20
>>> height = 5*9
>>> width * height
900</syntaxhighlight>

Если переменная не ''определена'' (не присвоено значение), попытка ее использования приведет к ошибке:

<syntaxhighlight lang="python">>>> n # попытка получить доступ к неопределённой переменной
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'n' is not defined</syntaxhighlight>

Полностью поддерживаются операции с плавающей точкой; операции над операндами смешанного типа конвертируют целочисленный операнд в число с плавающей точкой:

<syntaxhighlight lang="python">>>> 4 * 3.75 - 1
14.0</syntaxhighlight>

В интерактивном режиме последнее выведенное выражение сохраняется в переменной <code>_</code>. Это значит, что если вы используете Python в качестве настольного калькулятора — всегда есть способ продолжить вычисления с меньшими усилиями, например:

<syntaxhighlight lang="python">>>> tax = 12.5 / 100
>>> price = 100.50
>>> price * tax
12.5625
>>> price + _
113.0625
>>> round(_, 2)
113.06</syntaxhighlight>

Эта переменная для пользователя должна иметь статус ''только для чтения''. Не присваивайте ей явного значения — вы создадите независимую переменную с таким же именем, скрывающую встроенную переменную вместе с её магическим поведением.

В дополнение к целым и плавающим числам, Python поддерживает также другие типы чисел, такие как <code>Decimal</code> и <code>Fraction</code>. В Python также включена поддержка комплексных чисел, для обозначения мнимой части используется суффикс <code>j</code> или <code>J</code> (например, <code>3+5j</code>).

==== Строки ====

Помимо чисел, Python может работать со строками, которые, в свою очередь, могут быть заданы различными способами. Строки могут быть заключены в одинарные или двойные кавычки, это даст одинаковый результат. Символ <code>\<code> может использоваться для экранирования кавычек:

<syntaxhighlight lang="python">>>> 'spam eggs' # одинарные кавычки
'spam eggs'
>>> 'doesn\'t' # используем \' для экранирования одинарной кавычки...
"doesn't"
>>> "doesn't" # ... или используем двойные кавычки
"doesn't"
>>> '"Yes," they said.'
'"Yes," they said.'
>>> "\"Yes,\" they said."
'"Yes," they said.'
>>> '"Isn\'t," they said.'
'"Isn\'t," they said.'</syntaxhighlight>

Интерпретатор выводит результаты операций над строками, обрамляя в кавычки и экранируя обратным слэшем специальные символы. Это может выглядеть чуть не так, как было введено (обрамляющие кавычки могут быть другими), обе строки являются эквивалентными. Строка заключается в двойные кавычки, если строка содержит одинарные кавычки и ни одной двойной, иначе она заключается в одинарные кавычки. Функция <tt>print()</tt> производит более читаемый вывод, пропуская внешние кавычки и выводя экранированные и специальные символы:
    
<syntaxhighlight lang="python">>>> '"Isn\'t," they said.'
'"Isn\'t," they said.'
>>> print('"Isn\'t," they said.')
"Isn't," they said.
>>> s = 'First line.\nSecond line.'  # \n обозначает перевод строки
>>> s  # без использования print(), \n включается в вывод
'First line.\nSecond line.'
>>> print(s)  # с print(), \n переводит строку
First line.
Second line.</syntaxhighlight>

Если не требуется интерпретировать символы, расположенные за <code>\<code>, как специальные, можно воспользоваться <code>raw<code> строками, для этого добавьте <code>r<code> перед первой кавычкой:

<syntaxhighlight lang="python">>>> print('C:\some\name')  # здесь \n означает перевод строки!
C:\some
ame
>>> print(r'C:\some\name')  # обратите внимание на r перед кавычкой
C:\some\name</syntaxhighlight>    
Строковые литералы могут быть занимать несколько строк. Один из способов - обрамление парой тройных кавычек: <code>"""</code> или <code><nowiki>'''</nowiki></code>. Переносы строк автоматически включаются в строку, но этого можно избежать с помощью добавления симовла <code>\<code> в конце строки. Следующий пример:

<syntaxhighlight lang="python">print("""\
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
""")</syntaxhighlight>

выведет следующий результат (обратите внимание, что первый перевод строки не был включен):

<pre>Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to</pre>

Строки могут конкатенироваться (склеиваться вместе) операцией <code>+</code> и быть повторенными операцией <code>*</code>:

<syntaxhighlight lang="python">>>> # 3 раза 'un', затем 'ium'
>>> 3 * 'un' + 'ium'
'unununium'</syntaxhighlight>

Два строковых литерала (т.е. то, что заключено в кавычки), расположенные друг за другом, автоматически конкатенируются.

<syntaxhighlight lang="python">>>> 'Py' 'thon'
'Python'</syntaxhighlight>

Эта возможность особенно полезна для разбиения длинных строк:

<syntaxhighlight lang="python">>>> text = ('Put several strings within parentheses '
...         'to have them joined together.')
>>> text
'Put several strings within parentheses to have them joined together.'</syntaxhighlight>
    
Это работает только для двух строковых литералов, не для переменных или выражений:

<syntaxhighlight lang="python">>>> prefix = 'Py'</syntaxhighlight>

<syntaxhighlight lang="python">>>> prefix 'thon'  # нельзя конкатенировать переменную со строковым литералом
  File "<stdin>", line 1
    prefix 'thon'
                ^
SyntaxError: invalid syntax
>>> ('un' * 3) 'ium'
  File "<stdin>", line 1
    ('un' * 3) 'ium'
                   ^
SyntaxError: invalid syntax</syntaxhighlight>
    
Если нужно конкатенировать переменные или переменную и литерал - используйте <code>+</code>:

<syntaxhighlight lang="python">>>> prefix + 'thon'
'Python'</syntaxhighlight>
    
Строки могут быть проиндексированы (subscripted), первый символ строки имеет индекс <tt>0</tt>. Отсутствует отдельный тип для символов; символ является строкой с единичной длиной:
    
<syntaxhighlight lang="python">>>> word = 'Python'
>>> word[0] # символ в позиции 0
'P'
>>> word[5] # символ в позиции 5
'n'</syntaxhighlight>

Индексы могут иметь отрицательные значения, тогда отсчет начнется справа:    

<syntaxhighlight lang="python">>>> word[-1]  # последний символ
'n'
>>> word[-2]  # второй с конца символ
'o'
>>> word[-6]
'P'</syntaxhighlight>
    
Заметьте, что так как -0 - это то же самое, что 0, отрицательные индексы начинаются с -1.
   
В дополнение к индексированию, поддерживаются срезы (slices). Индексирование используется для получения отдельных символов, срезы позволяют вам получить подстроку:

<syntaxhighlight lang="python">>>> word[0:2]  # символы с позиции 0 (включая ее) до позиции 2 (исключая ее)
'Py'
>>> word[2:5]  # символы с позиции 2 (включая ее=) до позиции 5 (исключая ее)
'tho'</syntaxhighlight>

Заметьте - начало всегда включено, конец - всегда исключен. Это обеспечивает то, что <code>s[:i] + s[i:]</code> всегда равно <code>s</code>:

<syntaxhighlight lang="python">>>> word[:2] + word[2:]
'Python'
>>> word[:4] + word[4:]
'Python'</syntaxhighlight>
    
Индексы срезов имеют полезные значения по умолчанию; опущенный первый индекс заменяется нулём, опущенный второй индекс подменяется размером срезаемой строки.

<syntaxhighlight lang="python">>>> word[:2]   # символы с начала строки до позиции 2 (включая ее)
'Py'
>>> word[4:]   # символы с позиции 4 (включая ее) до конца строки
'on'
>>> word[-2:]  # символы со второго с конца символа (включая его) до конца строки
'on'</syntaxhighlight>
    
Один из способов запомнить, как работают срезы — думать о них, как об указателях на места между символами, где левый край первого символа установлен в ноль, а правый край последнего символа строки из <code>n</code> символов имеет индекс <code>n</code>, например:

<pre> +---+---+---+---+---+---+
 | P | y | t | h | o | n |
 +---+---+---+---+---+---+
 0   1   2   3   4   5   6
-6  -5  -4  -3  -2  -1</pre>

Первый ряд чисел дает позицию индексов строки от 0 до 6; второй ряд описывает соответствующие отрицательные индексы. Срез от i до j состоит из всех символов между правым и левым краями, отмеченными, соответственно, через <code>i</code> и <code>j</code>.

Для всех индексов, больших или равных нулю, длина среза — разность между индексами, при условии что оба индекса находятся в диапазоне. Например, длина <code>word[1:3]</code> — 2.
    
Попытка использовать слишком большой индекс приведет к ошибке:

<syntaxhighlight lang="python">>>> word[42]  # переменная word содержит только 6 символов
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: string index out of range</syntaxhighlight>
    
Однако, использование слишком большого индекса в срезах отрабатывает корректно:

<syntaxhighlight lang="python">>>> word[4:42]
'on'
>>> word[42:]
''</syntaxhighlight>
    
Строки Python не могут быть изменены. Присваивание значения по позиции индекса в строке вызывает ошибку:

<syntaxhighlight lang="python">>>> word[0] = 'J'
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
TypeError: 'str' object doesn't support item assignment
>>> word[2:] = 'py'
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
TypeError: 'str' object doesn't support slice assignment</syntaxhighlight>

Если Вам нужна другая строка - необходимо создать новую:
 
<syntaxhighlight lang="python">>>> 'J' + word[1:]
'Jython'
>>> word[:2] + 'py'
'Pypy'</syntaxhighlight>

Встроенная функция <code>len()</code> возвращает длину строки:

<syntaxhighlight lang="python">>>> s = 'supercalifragilisticexpialidocious'
>>> len(s)
34</syntaxhighlight>

==== Списки ====

В языке Python доступно некоторое количество ''составных'' типов данных, использующихся для группировки значений других типов. Наиболее разносторонний из них — список (<tt>list</tt>). Его можно выразить в тексте программы через разделённые запятыми значения (''элементы''), заключённые в квадратные скобки. Элементы списка могут быть разных типов, хотя обычно все элементы имеют один тип.

<syntaxhighlight lang="python">>>> squares = [1, 4, 9, 16, 25]
>>> squares
[1, 4, 9, 16, 25]</syntaxhighlight>

Подобно строкам (и всем другим встроенным sequence типам), списки могут индексироваться и быть срезаны:

<syntaxhighlight lang="python">>>> squares[0]  # индексация возвращает элемент
1
>>> squares[-1]
25
>>> squares[-3:]  # срез возвращает новый список
[9, 16, 25]</syntaxhighlight>

Все операции среза возвращают новый список, содержащий требуемые элементы. Это означает. что следующий срез вернет shallow копию списка:

<syntaxhighlight lang="python">>>> squares[:]
[1, 4, 9, 16, 25]</syntaxhighlight>
    
Списки также поддерживают опеацию конкатенации:

<syntaxhighlight lang="python">>>> squares + [36, 49, 64, 81, 100]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</syntaxhighlight>
    
В отличие от строк, являющихся неизменяемыми, списки - изменяемый тип данных, то есть можно изменить состав списка:

<syntaxhighlight lang="python">>>> cubes = [1, 8, 27, 65, 125]  # что-то не так с числами
>>> 4 ** 3  # 4 в кубе - 64, не 65!
64
>>> cubes[3] = 64  # заменим неправильное значение
>>> cubes
[1, 8, 27, 64, 125]</syntaxhighlight>
    
Вы можете добавить новые элементы в конец списка с помощью метода <code>append()</code> (мы позже поговорим о методах подробнее):

<syntaxhighlight lang="python">>>> cubes.append(216)  # добавим 6 в кубе
>>> cubes.append(7 ** 3)  # и 7 в кубе
>>> cubes
[1, 8, 27, 64, 125, 216, 343]</syntaxhighlight>

Присваивание срезу также возможно, и это действие может даже изменить размер списка или полностью его очистить:

<syntaxhighlight lang="python">>>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
>>> letters
['a', 'b', 'c', 'd', 'e', 'f', 'g']
>>> # заменим некоторые значения
>>> letters[2:5] = ['C', 'D', 'E']
>>> letters
['a', 'b', 'C', 'D', 'E', 'f', 'g']
>>> # теперь удалим их
>>> letters[2:5] = []
>>> letters
['a', 'b', 'f', 'g']
>>> # очистим список, заменив всего его элементы пустым списком
>>> letters[:] = []
>>> letters
[]</syntaxhighlight>

Встроенная функция <code>len()</code> также применима к спискам:

<syntaxhighlight lang="python">>>> a = ['a', 'b', 'c', 'd']
>>> len(a)
4</syntaxhighlight>

Вы можете делать вложенные списки (создавать списки, содержащие другие списки), например так:

<syntaxhighlight lang="python">>>> a = ['a', 'b', 'c']
>>> n = [1, 2, 3]
>>> x = [a, n]
>>> x
[['a', 'b', 'c'], [1, 2, 3]]
>>> x[0]
['a', 'b', 'c']
>>> x[0][1]
'b'</syntaxhighlight>

=== Первые шаги к программированию ===

Безусловно, Python можно использовать для более сложных задач, чем вычисление два плюс два. Например, мы можем вывести начало последовательности чисел Фибоначчи таким образом:

<syntaxhighlight lang="python">>>> # Ряд Фибоначчи:
... # сумма двух элементов определяет следущий элемент
... a, b = 0, 1
>>> while b < 10:
...     print(b)
...     a, b = b, a+b
...
1
1
2
3
5
8</syntaxhighlight>

Этот пример показывает нам некоторые новые возможности.

* Первая строка содержит ''множественное присваивание'' (<tt>multiple assignment</tt>): переменные <code>a</code> и <code>b</code> параллельно получают новые значения — <code>0</code> и <code>1</code>. В последней строке этот метод используется снова, демонстрируя то, что выражения по правую сторону [от оператора присваивания] всегда вычисляются раньше присваиваний. Сами же выражения справа от присваивания вычисляются слева направо.

* Цикл <code>while</code> (пока) исполняется до тех пор, пока условие (здесь: <code>b < 10</code>) остается истиной. В Python, также как и в C, любое ненулевое значение является истиной (<code>True</code>); ноль является ложью (<code>False</code>). Условием может быть строка, список или вообще любая последовательность; все, что имеет ненулевую длину, имеет значение истина, пустая последовательность — ложь. Использованная в примере проверка — простое условие. Стандартные операции сравнения записываются так же, как и в C: <code><</code> (меньше чем), <code>></code> (больше чем), <code>==</code> (равно), <code><=</code> (меньше или равно), <code>>=</code> (больше или равно) и <code>!=</code> (не равно).

* ''Тело'' цикла выделено ''отступом'' (<tt>indented</tt>). Отступы — это средство группировки операторов в Python. В интерактивном режиме необходимо использовать табуляции или пробелы для отступа в каждой строке. На практике более сложный текст на Python готовится в текстовом редакторе, большинство из которых имеют функцию авто-отступа. По окончании ввода составного оператора в интерактивном режиме его необходимо закончить пустой строкой — признаком завершения (поскольку интерпретатор не может угадать, когда вами была введена последняя строка). Обратите внимание, что размер отступа в каждой строке одного блока должен быть одним и тем же.

* Функция <code>print()</code> выводит значения переданных ей выражений. Поведение этой функции отличается от обычного вывода выражения (как происходило выше в примерах с калькулятором) тем, каким способом обрабатываются несколько аргументов, величины с плавающей точкой и строки. Строки выводятся без кавычек, и между элементами вставляются пробелы, благодаря чему форматирование вывода улучшается — как, например, здесь:
    
<syntaxhighlight lang="python">>>> i = 256*256
>>> print('Значением i является', i)
Значением i является 65536</syntaxhighlight>
    
Для отключения перевода строки после вывода или завершения вывода другой строкой используется именованный параметр <code>end</code>:

<syntaxhighlight lang="python">>>> a, b = 0, 1
>>> while b < 1000:
...     print(b, end=',')
...     a, b = b, a+b
...
1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,</syntaxhighlight>

