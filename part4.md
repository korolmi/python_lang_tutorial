
== Неформальное введение в Python ==

В приведенных далее примерах, ввод и вывод различаются присутствием и отсутствием приглашений соответственно (приглашениями являются <tt>>>></tt> и <tt>...</tt>): чтобы воспроизвести пример — вам нужно ввести всё, что следует за приглашением, после его появления; строки, не начинающиеся с приглашений являются выводом интерпретатора. Обратите внимание, что строка, в которой содержится лишь вспомогательное приглашение («<tt>... </tt>») означает, что вам нужно ввести пустую строку — этот способ используется для завершения многострочных команд.

Большинство примеров в этом руководстве — даже те, которые вводятся в интерактивном режиме — содержат комментарии. Комментарии в Python начинаются с символа решетки # (<tt>hash</tt>) — и продолжаются до физического конца строки. Комментарии могут находиться как в начале строки, так и следовать за пробельными символами или кодом — но не содержаться внутри строки. Символ решётки в строке остаётся лишь символом решётки. Поскольку комментарии предназначены для того, чтобы сделать код более понятным, и не интерпретируются Python — при вводе примеров они могут быть опущены.

Несколько примеров:

<syntaxhighlight lang="python"># это первый комментарий
SPAM = 1                 # а это второй комментарий
                         # ... и наконец третий!
STRING = "# Это не комментарий."</syntaxhighlight>

=== Использование Python в качестве калькулятора ===

Давайте опробуем несколько простых команд Python. Запустите интерпретатор и дождитесь появления основного приглашения — <tt>>>></tt>. (Это не должно занять много времени.)

==== Числа ====
Вот вам маленький пример:
print("Привет, как дела?")

Поведение интерпретатора сходно поведению калькулятора: вы вводите выражение, а в ответ он выводит значение. Синтаксис выражений привычен: операции <code>+</code>, <code>-</code>, <code>*</code> и <code>/</code> работают так же как и в большинстве других языков (например, Паскале или C); для группировки можно использовать скобки. Например:

<syntaxhighlight lang="python">>>> 2+2
4
>>> # Это комментарий
... 2+2
4
>>> 2+2  # а вот комментарий на одной строке с кодом
4
>>> (50-5*6)/4
5.0
>>> 8/5 # При делении целых чисел дробные части не теряются
1.6000000000000001
</syntaxhighlight>

''Заметьте'': Вы можете получить результат, несколько отличный от представленного: результаты деления с плавающей запятой могут различаться на разных системах. Позже мы расскажем о том, как контролировать вывод чисел с плавающей запятой. Здесь использован наиболее информативный вариант вывода этого значения, а не более легко-читаемый, какой возможен:
<syntaxhighlight lang="python">>>> print(8/5)
1.6
</syntaxhighlight>

Чтобы учебник читался легче, мы будем показывать упрощённый вывод чисел с плавающей точкой и объясним позже, почему эти два способа отображения чисел с плавающей точкой стали различными. Обратитесь к приложению [[Учебник Python 3.1 — Приложения#Арифметика с плавающей точкой - Проблемы и ограничения|Арифметика с плавающей точкой: Проблемы и ограничения]], чтобы ознакомиться с подробным обсуждением.

Для получения целого результата при делении целых чисел, отсекая дробные результаты, предназначена другая операция: <tt>//</tt>:

<syntaxhighlight lang="python">>>> # Деление целых чисел возвращает округлённое к минимальному значение:
... 7//3
2
>>> 7//-3
-2</syntaxhighlight>

Знак равенства (<code>'='</code>) используется для присваивания переменной какого-либо значения. После этого действия в интерактивном режиме ничего не выводится:

<syntaxhighlight lang="python">>>> width = 20
>>> height = 5*9
>>> width * height
900</syntaxhighlight>

Значение может быть присвоено нескольким переменным одновременно:

<syntaxhighlight lang="python">>>> x = y = z = 0  # Нулевые x, y и z
>>> x
0
>>> y
0
>>> z
0</syntaxhighlight>

Переменные должны быть ''определены'' (<tt>defined</tt>) (должны иметь присвоенное значение) перед использованием, иначе будет сгенерирована ошибка:

<syntaxhighlight lang="python">>>> # попытка получить доступ к неопределённой переменной
... n
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'n' is not defined</syntaxhighlight>

Присутствует полная поддержка операций с плавающей точкой; операции над операндами смешанного типа конвертируют целочисленный операнд в число с плавающей запятой:

<syntaxhighlight lang="python">>>> 3 * 3.75 / 1.5
7.5
>>> 7.0 / 2
3.5</syntaxhighlight>

Поддерживаются и комплексные числа, добавлением к мнимым частям суффикса <code>j</code> или <code>J</code>. Комплексные числа с ненулевым вещественным компонентом записываются в виде <code>(''<вещественная_часть>''+''<мнимая_часть>''j)</code>, или могут быть созданы с помощью функции <code>complex(''<вещественная_часть>'', ''<мнимая_часть>'')</code>.

<syntaxhighlight lang="python">>>> 1j * 1J
(-1+0j)
>>> 1j * complex(0, 1)
(-1+0j)
>>> 3+1j*3
(3+3j)
>>> (3+1j)*3
(9+3j)
>>> (1+2j)/(1+1j)
(1.5+0.5j)</syntaxhighlight>

Комплексные числа всегда представлены в виде двух чисел с плавающей запятой — вещественной и мнимой частями. Для получения этих частей из комплексного числа <code>z</code> используется <code>z.real</code> и <code>z.imag</code> соответственно.

<syntaxhighlight lang="python">>>> a=1.5+0.5j
>>> a.real
1.5
>>> a.imag
0.5</syntaxhighlight>

Функции конвертации (приведения) к вещественным и целым числам (<code>float()</code>, <code>int()</code>) не работают с комплексными числами, так как нет единственно правильного способа сконвертировать комплексное число в вещественное. Используйте функцию <code>abs(z)</code> чтобы получить ''модуль'' числа (в виде числа с плавающей точкой) или <code>z.real</code> чтобы получить его вещественную часть:

<syntaxhighlight lang="python">>>> a=3.0+4.0j
>>> float(a)
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
TypeError: can`t convert complex to float; use abs(z)
>>> a.real
3.0
>>> a.imag
4.0
>>> abs(a)  # sqrt(a.real**2 + a.imag**2)
5.0
>>></syntaxhighlight>

В интерактивном режиме последнее выведенное выражение сохраняется в переменной <code>_</code>. Это значит, что если вы используете Python в качестве настольного калькулятора — всегда есть способ продолжить вычисления с меньшими усилиями, например:

<syntaxhighlight lang="python">>>> tax = 12.5 / 100
>>> price = 100.50
>>> price * tax
12.5625
>>> price + _
113.0625
>>> round(_, 2)
113.06
>>></syntaxhighlight>

Эта переменная для пользователя должна иметь статус ''только для чтения''. Не навязывайте ей значение собственноручно — вы создадите независимую переменную с таким же именем, скрывающую встроенную переменную вместе с её магическими свойствами.

==== Строки ====

Помимо чисел, Python может работать со строками, которые, в свою очередь, могут быть описаны различными способами. Строки могут быть заключены в одинарные или двойные кавычки:

<syntaxhighlight lang="python">>>> 'spam eggs'
'spam eggs'
>>> 'doesn\'t'
"doesn't"
>>> "doesn't"
"doesn't"
>>> '"Yes," he said.'
'"Yes," he said.'
>>> "\"Yes,\" he said."
'"Yes," he said.'
>>> '"Isn\'t," she said.'
'"Isn\'t," she said.'</syntaxhighlight>

Интерпретатор выводит результаты операций над строками тем же способом, каким они были введены: обрамляя в кавычки, и, кроме того, экранируя обратными слэшами внутренние кавычки и другие забавные символы — для того, чтобы отобразить точное значение. Строка заключается в двойные кавычки, если строка содержит одинарные кавычки и ни одной двойной, иначе она заключается в одинарные кавычки. Повторимся, функция <tt>print()</tt> предоставляет более читаемый вывод.

Строковые литералы могут быть разнесены на несколько строк различными способами. Могут быть использованы ''продолжающие строки'', с обратным слэшем в качестве последнего символа строки, сообщающим о том, что следующая строка есть продолжение текущей<ref>''(Прим. перев.):''<syntaxhighlight lang="python">hello = "Это довольно длинная строка, содержащая\n\
 несколько строк текста — такой вы бы представили её в C.\n\
    Обратите внимание, что пробельное пространство в начале строки\
 имеет значение."

print(hello)</syntaxhighlight></ref>:

<syntaxhighlight lang="python">hello = "This is a rather long string containing\n\
 several lines of text just as you would do in C.\n\
    Note that whitespace at the beginning of the line is\
 significant."

print(hello)</syntaxhighlight>

Обратите внимание, что новые строки все ещё нужно подключать в строку через <code>\n</code>; символ новой строки, перед которым идёт обратный слэш — не обрабатывается. Запуск примера выведет следующее:

<pre>This is a rather long string containing
several lines of text just as you would do in C.
    Note that whitespace at the beginning of the line is significant.</pre>

Если мы объявим строковой литерал ''сырым'' (<tt>raw</tt>)<ref>''(Прим. перев.)'' ''raw string'' — для описания ''сырой строки'' (не требующей последующей обработки) используется префикс '''<code>r</code>'''.</ref> — символы <code>\n</code> не будут конвертированы в новые строки, но и обратный слэш в конце строки, и символ новой строки в исходном коде — будут добавлены в строку в виде данных. Следовательно, код из примера:

<syntaxhighlight lang="python">hello = r"This is a rather long string containing\n\
several lines of text much as you would do in C."

print(hello)</syntaxhighlight>

выведет:

<pre>This is a rather long string containing\n\
several lines of text much as you would do in C.</pre>

Или, строки могут быть обрамлены совпадающей парой тройных кавычек: <code>"""</code> или <code><nowiki>'''</nowiki></code>. Окончания строк не нужно завершать тройными кавычками — при этом будут включены в строку.

<syntaxhighlight lang="python">print("""
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
""")</syntaxhighlight>

выводит в результате следующее:

<syntaxhighlight lang="text">Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to</syntaxhighlight>

Строки могут конкатенироваться (склеиваться вместе) операцией <code>+</code> и быть повторенными операцией <code>*</code>:

<syntaxhighlight lang="python">>>> word = 'Help' + 'A'
>>> word
'HelpA'
>>> '<' + word*5 + '>'
'<HelpAHelpAHelpAHelpAHelpA>'</syntaxhighlight>

Два строковых литерала, расположенные друг за другом, автоматически конкатенируются; первая строка в предыдущем примере также могла быть записана как <code>word = 'Help' 'A'</code>; это работает только с двумя литералами — не с произвольными выражениями, содержащими строки.

<syntaxhighlight lang="python">>>> 'str' 'ing'                   #  <-  Так — верно
'string'
>>> 'str'.strip() + 'ing'   #  <-  Так — верно
'string'
>>> 'str'.strip() 'ing'     #  <-  Так — не верно
  File "<stdin>", line 1, in ?
    'str'.strip() 'ing'
                      ^
SyntaxError: invalid syntax</syntaxhighlight>

Строки могут быть проиндексированы; также как и в C, первый символ строки имеет индекс <tt>0</tt>. Отсутствует отдельный тип для символов; символ является строкой с единичной длиной. Как и в языке программирования Icon, подстроки могут определены через нотацию срезов (<tt>slice</tt>): два индекса, разделенных двоеточием.

<syntaxhighlight lang="python">>>> word[4]
'A'
>>> word[0:2]
'He'
>>> word[2:4]
'lp'</syntaxhighlight>

Индексы срезов имеют полезные значения по умолчанию; опущенный первый индекс заменяется нулём, опущенный второй индекс подменяется размером срезаемой строки.

<syntaxhighlight lang="python">>>> word[:2]    # Первые два символа
'He'
>>> word[2:]    # Всё, исключая первые два символа
'lpA'</syntaxhighlight>

В отличие от строк в C, строки Python не могут быть изменены. Присваивание по позиции индекса строки вызывает ошибку:

<syntaxhighlight lang="python">>>> word[0] = 'x'
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
TypeError: 'str' object doesn't support item assignment
>>> word[:1] = 'Splat'
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
TypeError: 'str' object doesn't support slice assignment</syntaxhighlight>

Тем не менее, создание новой строки со смешанным содержимым — процесс легкий и очевидный:

<syntaxhighlight lang="python">>>> 'x' + word[1:]
'xelpA'
>>> 'Splat' + word[4]
'SplatA'</syntaxhighlight>

Полезный инвариант операции среза: <code>s[:i] + s[i:]</code> эквивалентно <code>s</code>.

<syntaxhighlight lang="python">>>> word[:2] + word[2:]
'HelpA'
>>> word[:3] + word[3:]
'HelpA'</syntaxhighlight>

Вырождения индексов срезов обрабатываются элегантно: чересчур большой индекс заменяется на размер строки, а верхняя граница меньшая нижней возвращает пустую строку.

<syntaxhighlight lang="python">>>> word[1:100]
'elpA'
>>> word[10:]
''
>>> word[2:1]
''</syntaxhighlight>

Индексы могут быть отрицательными числами, обозначая при этом отсчет справа налево. Например:

<syntaxhighlight lang="python">>>> word[-1]     # Последний символ
'A'
>>> word[-2]     # Предпоследний символ
'p'
>>> word[-2:]    # Последние два символа
'pA'
>>> word[:-2]    # Всё, кроме последних двух символов
'Hel'</syntaxhighlight>

Но обратите внимание, что <tt>-0</tt> действительно эквивалентен <tt>0</tt> — это не отсчет справа.

<syntaxhighlight lang="python">>>> word[-0]     # (поскольку -0 равен 0)
'H'</syntaxhighlight>

Отрицательные индексы вне диапазона обрезаются, но не советуем делать это с одно-элементными индексами (''не-срезами''):

<syntaxhighlight lang="python">>>> word[-100:]
'HelpA'
>>> word[-10]    # ошибка
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
IndexError: string index out of range</syntaxhighlight>

Один из способов запомнить, как работают срезы — думать о них, как об указателях на места между символами, где левый край первого символа установлен в ноль, а правый край последнего символа строки из <code>n</code> символов имеет индекс <code>n</code>, например:

<pre> +---+---+---+---+---+
 | H | e | l | p | A |
 +---+---+---+---+---+
 0   1   2   3   4   5
-5  -4  -3  -2  -1</pre>

Первый ряд чисел дает позицию индексов строки от 0 до 5; второй ряд описывает соответствующие отрицательные индексы. Срез от i до j состоит из всех символов между правым и левым краями, отмеченными, соответственно, через <code>i</code> и <code>j</code>.

Для всех индексов, больших или равных нулю, длина среза — разность между индексами, при условии что оба индекса находятся в диапазоне. Например, длина <code>word[1:3]</code> — 2.

Встроенная функция <code>len()</code> возвращает длину строки<ref>''(Прим. перев.)'': [[w:en:Supercalifragilisticexpialidocious|Supercalifragilisticexpialidocious]] — английское слово из одноименной песни, прозвучавшей в фильме [[w:en:Mary Poppins (film)|Мэри Поппинс]]</ref>:

<syntaxhighlight lang="python">>>> s = 'supercalifragilisticexpialidocious'
>>> len(s)
34</syntaxhighlight>

{{Смотрите также|
;[[Справочник по библиотеке Python 3.1#Перечисляемые типы|Перечисляемые типы]]: Строки — вид перечисляемых типов и они поддерживают привычные для этих типов операции.
;[[Справочник по библиотеке Python 3.1#Строковые методы|Строковые методы]]: Строки поддерживают большое количество методов для поиска и простых трансформаций.
;[[Справочник по библиотеке Python 3.1#Форматирование строк|Форматирование строк]]: Здесь описано форматирование строк с применением функции <code>str.format()</code>
;[[Справочник по библиотеке Python 3.1#Форматирование строк в старом стиле|Операции форматирования строк в старом стиле]]:Операции форматирования, вызывающиеся тогда, когда обычные строки или строки в Unicode оказываются левым операндом относительно операции <code>%</code>, более детально рассмотрены здесь.<ref>''(Прим. перев.) Эти операции будут отключены в финальном релизе 3.1''</ref>
}}

==== О Unicode ====

Начиная с Python версии 3.0, строковый тип поддерживает только Unicode (см. http://www.unicode.org/).

Преимущество набора Unicode состоит в том, что он предоставляет порядковый номер для любого символа из любой письменности, использовавшейся в современных или древнейших текстах. До этих пор для символов в сценарии было доступно лишь 256 номеров. Тексты обычно привязывались к кодовой странице, которая устанавливала в соответствие порядковые номера и символы сценария. Это приводило к серьезной путанице, особенно в том, что касалось интернационализации<ref>Часто записывается как <tt>'''i18n'''</tt> — <tt>''internationalization'' = '''i''' + '''18''' символов + '''n'''</tt></ref> программного продукта. Unicode решает эти проблемы, определяя единую кодовую страницу для всех письменностей.

Для вставки в строку специального символа можно использовать Unicode-экранирование (<tt>Python Unicode-Escape encoding</tt>). Следующий пример всё пояснит:

<syntaxhighlight lang="python">>>> 'Hello\u0020World !'
'Hello World !'</syntaxhighlight>

Экранированная последовательность <code>\u0020</code> задаёт символ Unicode с порядковым номером <tt>0x0020</tt> (символ пробела).

Другие символы интерпретируются с использованием соответствующих им порядковых значений тем же способом, что и порядковые номера Unicode. Первые 128 символов кодировки Unicode полностью совпадают с 128 символами кодировки <tt>Latin-1</tt>, использующейся во многих западных странах.

Помимо стандартных способов кодирования, Python предоставляет целый набор различных способов создания Unicode-строк, основываясь на известной кодировке.

Для конвертирования Unicode-строки в последовательность байтов с использованием желаемой кодировки, строковые объекты предоставляют метод <code>encode()</code>, принимающий единственный параметр — название кодировки. Предпочитаются названия кодировок, записанные в нижнем регистре.

<syntaxhighlight lang="python">>>>"Äpfel".encode('utf-8') 
b'\xc3\x84pfel'</syntaxhighlight>

==== Списки ====

В языке Python доступно некоторое количество ''составных'' типов данных, использующихся для группировки прочих значений вместе. Наиболее гибкий из них — список (<tt>list</tt>). Его можно выразить в тексте программы через разделённые запятыми значения (''элементы''), заключённые в квадратные скобки. Элементы списка могут быть разных типов.

<syntaxhighlight lang="python">>>> a = ['spam', 'eggs', 100, 1234]
>>> a
['spam', 'eggs', 100, 1234]</syntaxhighlight>

Подобно индексам в строках, индексы списков начинаются с нуля, списки могут быть срезаны, объединены (''конкатенированы'') и так далее:

<syntaxhighlight lang="python">>>> a[0]
'spam'
>>> a[3]
1234
>>> a[-2]
100
>>> a[1:-1]
['eggs', 100]
>>> a[:2] + ['bacon', 2*2]
['spam', 'eggs', 'bacon', 4]
>>> 3*a[:3] + ['Boo!']
['spam', 'eggs', 100, 'spam', 'eggs', 100, 'spam', 'eggs', 100, 'Boo!']</syntaxhighlight>

В отличие от строк, являющихся неизменяемыми, изменить индивидуальные элементы списка вполне возможно:

<syntaxhighlight lang="python">>>> a
['spam', 'eggs', 100, 1234]
>>> a[2] = a[2] + 23
>>> a
['spam', 'eggs', 123, 1234]</syntaxhighlight>

Присваивание срезу также возможно, и это действие может даже изменить размер списка или полностью его очистить:

<syntaxhighlight lang="python">>>> # Заменим некоторые элементы:
... a[0:2] = [1, 12]
>>> a
[1, 12, 123, 1234]
>>> # Удалим немного:
... a[0:2] = []
>>> a
[123, 1234]
>>> # Вставим пару:
... a[1:1] = ['bletch', 'xyzzy']
>>> a
[123, 'bletch', 'xyzzy', 1234]
>>> # Вставим (копию) самого себя в начало
>>> a[:0] = a
>>> a
[123, 'bletch', 'xyzzy', 1234, 123, 'bletch', 'xyzzy', 1234]
>>> # Очистка списка: замена всех значений пустым списком
>>> a[:] = []
>>> a
[]</syntaxhighlight>

Встроенная функция <code>len()</code> также применима к спискам:

<syntaxhighlight lang="python">>>> a = ['a', 'b', 'c', 'd']
>>> len(a)
4</syntaxhighlight>

Вы можете встраивать списки (создавать списки, содержащие другие списки), например так:

<syntaxhighlight lang="python">>>> q = [2, 3]
>>> p = [1, q, 4]
>>> len(p)
3
>>> p[1]
[2, 3]
>>> p[1][0]
2</syntaxhighlight>

Вы можете добавить что-нибудь в конец списка.

<syntaxhighlight lang="python">>>> p[1].append('xtra')
>>> p
[1, [2, 3, 'xtra'], 4]</syntaxhighlight>

Обратите внимание, что в последнем примере <code>p[1]</code> и <code>q</code> на самом деле ссылаются на один и тот же объект!

<syntaxhighlight lang="python">>>> q
[2, 3, 'xtra']</syntaxhighlight>

Мы вернёмся к ''семантике объектов'' позже.

=== Первые шаги к программированию ===

Безусловно, Python можно использовать для более сложных задач, чем сложение двух чисел. Например, мы можем вывести начало последовательности чисел Фибоначчи таким образом:

<syntaxhighlight lang="python">>>> # Ряд Фибоначчи:
... # сумма двух элементов определяет следущий элемент
... a, b = 0, 1
>>> while b < 10:
...     print(b)
...     a, b = b, a+b
...
1
1
2
3
5
8</syntaxhighlight>

Этот пример показывает нам некоторые новые возможности.

* Первая строка содержит ''множественное присваивание'' (<tt>multiple assignment</tt>): переменные <code>a</code> и <code>b</code> параллельно получают новые значения — <code>0</code> и <code>1</code>. В последней строке этот метод используется снова, демонстрируя тот факт, что выражения по правую сторону [от оператора присваивания] всегда вычисляются раньше каких бы то ни было присваиваний. Сами же разделённые запятыми выражения вычисляются слева направо.

* Цикл <code>while</code> (пока) исполняется до тех пор, пока условие (здесь: <code>b < 10</code>) остается истиной. В Python, также как и в C, любое ненулевое значение является истиной (<code>True</code>); ноль является ложью (<code>False</code>). Условием может быть строка, список или вообще любая последовательность; все, что имеет ненулевую длину, играет роль истины, пустые последовательности — лжи. Использованная в примере проверка — простое условие. Стандартные операции сравнения записываются так же, как и в C: <code><</code> (меньше чем), <code>></code> (больше чем), <code>==</code> (равно), <code><=</code> (меньше или равно), <code>>=</code> (больше или равно) и <code>!=</code> (не равно).

* ''Тело'' цикла выделено ''отступом'' (<tt>indented</tt>). Отступы — это средство группировки операторов в Python. Интерактивный режим Python (пока!) не имеет какого-либо разумного и удобного средства для редактирования строк ввода, поэтому необходимо использовать табуляции или пробелы для отступа в каждой строке. На практике более сложный текст на Python готовится в текстовом редакторе, большинство из которых имеют функцию авто-отступа. По окончании ввода составного выражения в интерактивном режиме его необходимо закончить пустой строкой — признаком завершения (поскольку интерпретатор не может угадать, когда вами была введена последняя строка). Обратите внимание, что размер отступа в каждой строке основного блока должен быть одним и тем же<ref>''(Прим. перев.)'' Размер отступа для блока не унифицирован — табуляция может чередоваться с пробелами, это может быть один пробел или же пять — главное, чтобы у всего блока он был одинаковым и был больше по величине чем у внешнего (обрамляющего) блока. Тем не менее, чаще всего программисты на Python устанавливают в редакторах режим замены табуляции четырьмя пробелами и при наборе кода вложенность блока обозначают отступом с соответствующим количеством нажатий клавиш табуляции. Благодаря этому код остается читабельным во всех текстовых редакторах и в большинстве браузеров (или, в редких случаях, требует минимального форматирования для корректного отображения)).''</ref>.

* Функция <code>print()</code> выводит значения переданных ей выражений. Поведение этой функции отличается от обычного вывода выражения (как происходило выше в примерах с калькулятором) тем, каким способом обрабатываются ряды выражений, величины с плавающей точкой и строки. Строки выводятся без кавычек, и между элементами вставляются пробелы, благодаря чему форматирование вывода улучшается — как, например, здесь:
<syntaxhighlight lang="python">>>> i = 256*256
>>> print('Значением i является', i)
Значением i является 65536</syntaxhighlight>
: Для отключения перевода строки после вывода или завершения вывода другой строкой используется именованный параметр <code>end</code>:
<syntaxhighlight lang="python">>>> a, b = 0, 1
>>> while b < 1000:
...     print(b, end=' ')
...     a, b = b, a+b
...
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987</syntaxhighlight>

