
== Ошибки и исключения ==

До этого момента сообщения об ошибках лишь упоминались, но если вы пробовали примеры на практике — возможно, вы уже видели некоторые. Существует (как минимум) два различимых вида ошибок: ''синтаксические ошибки'' (<tt>syntax errors</tt>) и ''исключения'' (<tt>exceptions</tt>).

=== Синтаксические ошибки ===

Синтаксические ошибки, также известные как ошибки разбора кода (''парсинга'', <tt>parsing</tt>) — вероятно, наиболее привычный вид жалоб компилятора, попадающихся вам при изучении Python:

<syntaxhighlight lang="python">>>> while True print('Hello world')
  File "<stdin>", line 1, in ?
    while True print('Hello world')
                   ^
SyntaxError: invalid syntax</syntaxhighlight>

Парсер<ref>''(Прим. перев.)'' ''Parser'' {{ref-en}} — программа синтаксического анализа, синтаксический анализатор; программа грамматического разбора</ref> повторно выводит ошибочную строку и отображает небольшую «стрелку», указывающую на самую первую позицию в строке, где была обнаружена ошибка. Причина ошибки (или по крайней мере место обнаружения) находится в символе<ref>''(Прим. перев.)'' ''Token'' {{ref-en}} — некоторая смысловая единица выражения: оператор, ключевое слово, значение переменной, …</ref>, предшествующем указанному: в приведённом примере ошибка обнаружена на месте вызова функции <code>print()</code>, поскольку перед ним пропущено двоеточие (<code>':'</code>). Также здесь выводятся имя файла и номер строки, благодаря этому вы знаете в каком месте искать, если ввод был сделан из сценария.

=== Исключения ===

Даже если выражение или оператор синтаксически верны, они могут вызвать ошибку при попытке их исполнения. Ошибки, обнаруженные при исполнении, называются ''исключениями'' (<tt>exceptions</tt>). Они не фатальны: позже вы научитесь перехватывать их в программах на Python. Большинство исключений, правда, как правило, не обрабатываются программами и приводят к сообщениям об ошибке, таким как следующие:

<syntaxhighlight lang="python">>>> 10 * (1/0)
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
ZeroDivisionError: int division or modulo by zero
>>> 4 + spam*3
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
NameError: name 'spam' is not defined
>>> '2' + 2
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
TypeError: coercing to Unicode: need string or buffer, int found</syntaxhighlight>

Последняя строка сообщения об ошибке описывает произошедшее. Исключения представлены различными типами и тип исключения выводится в качестве части сообщения: в примере это типы <code>ZeroDivisionError</code>, <code>NameError</code> и <code>TypeError</code>. Часть строки, описывающая тип исключения — это имя произошедшего встроенного исключения. Такое утверждение верно для всех встроенных исключений, но не обязано быть истинным для исключений, определённых пользователем (однако, само соглашение — довольно полезное). Имена стандартных исключений — это встроенные идентификаторы (не ключевые слова).

Оставшаяся часть строки описывает детали произошедшего на основе типа исключения, которое было его причиной.

Предшествующая часть сообщения об ошибке показывает контекст, где произошло исключение, в форме стека вызовов. В общем случае она содержит стек, состоящий из списка строк исходного кода; тем не менее, в неё не войдут строки, прочитанные из стандартного ввода.

В разделе [[Справочник по библиотеке Python 3.1#Встроенные исключения|Встроенные исключения]] [[Справочник по библиотеке Python 3.1|Справочника по библиотеке]] вы найдёте список встроенных исключений и их значений.

=== Обработка исключений ===

Существует возможность написать код, который будет перехватывать избранные исключения. Посмотрите на представленный пример, в котором пользователю предлагают вводить число до тех пор, пока оно не окажется корректным целым. Тем не менее, пользователь может прервать программу (используя сочетание клавиш <tt>Control-C</tt> или какое-либо другое, поддерживаемое операционной системой); заметьте — о вызванном пользователем прерывании сигнализирует исключение <code>KeyboardInterrupt</code>.

<syntaxhighlight lang="python">>>> while True:
...     try:
...         x = int(input("Введите, пожалуйста, число: "))
...         break
...     except ValueError:
...         print("Ой!  Это некорректное число.  Попробуйте ещё раз...")
...</syntaxhighlight>

Оператор <code>try</code> работает следующим образом:

* В начале исполняется ''блок <code>try</code>'' (операторы между ключевыми словами <code>try</code> и <code>except</code>).

* Если при этом не появляется исключений, ''блок <code>except</code>'' не выполняется и оператор <code>try</code> заканчивает работу.

* Если во время выполнения блока <code>try</code> было возбуждено какое-либо исключение, оставшаяся часть блока не выполняется. Затем, если тип этого исключения совпадает с исключением, указанным после ключевого слова <code>except</code>, выполняется блок <code>except</code>, а по его завершению выполнение продолжается сразу после оператора <code>try-except</code>.

* Если порождается исключение, не совпадающее по типу с указанным в блоке <code>except</code> — оно передаётся внешним операторам <code>try</code>; если ни одного обработчика не найдено, исключение считается ''необработанным'' (<tt>unhandled exception</tt>), и выполнение полностью останавливается и выводится сообщение, схожее с показанным выше.

Оператор <code>try</code> может иметь более одного блока <code>except</code> — для описания обработчиков различных исключений. При этом будет выполнен максимум один обработчик. Обработчики ловят только те исключения, которые возникают внутри соответствующего блока <code>try</code>, но не те, которые возникают в других обработчиках этого же самого оператора <code>try-except</code>. Блок <code>except</code> может указывать несколько исключений в виде заключённого в скобки кортежа, например:

<syntaxhighlight lang="python">... except (RuntimeError, TypeError, NameError):
...     pass</syntaxhighlight>

В последнем блоке <code>except</code> можно не указывать имени (или имён) исключений. Тогда он будет действовать как обработчик группы исключений. Используйте эту возможность с особой осторожностью, поскольку таким образом он может с лёгкостью перехватить и фактическую ошибку программиста! Также такой обработчик может быть использован для вывода сообщения об ошибке и порождения исключения заново (позволяя при этом обработать исключение коду, вызвавшему обработчик):

<syntaxhighlight lang="python">import sys

try:
    f = open('myfile.txt')
    s = f.readline()
    i = int(s.strip())
except IOError as err:
    print("I/O error: {0}".format(err))
except ValueError:
    print("Не могу преобразовать данные в целое.")
except:
    print("Неожиданная ошибка:", sys.exc_info()[0])
    raise</syntaxhighlight>

У оператора <code>try-except</code> есть необязательный ''блок <code>else</code>'', который, если присутствует, должен размещаться после всех блоков <code>except</code>. Его полезно использовать при наличии кода, который должен быть выполнен, если блок <code>try</code> не породил исключений. Например:

<syntaxhighlight lang="python">for arg in sys.argv[1:]:
    try:
        f = open(arg, 'r')
    except IOError:
        print('не могу открыть', arg)
    else:
        print(arg, 'содержит', len(f.readlines()), 'строк')
        f.close()</syntaxhighlight>

Использование блока <code>else</code> предпочтительнее, чем добавление дополнительного кода к блоку <code>try</code>, поскольку исключает неожиданный перехват исключения, которое появилось не по причине выполнения кода, защищенного оператором <code>try-except</code>.

При появлении исключения, оно может иметь ассоциированное значение, также известное как ''аргумент'' (<tt>argument</tt>) исключения. Присутствие и тип аргумента зависят от типа самого исключения.

В блоке <code>except</code> можно указать переменную, следующую за именем исключения. Переменная связывается с экземпляром исключения, аргументы которого хранятся в <code>instance.args</code>. Для удобства, экземпляр исключения определяет метод <code>__str__()</code>, так что вывод аргументов может быть произведён явно, без необходимости отсылки к <code>.args</code>. Таким образом, вы также можете создать/взять экземпляр исключения перед его порождением и добавить к нему атрибуты по желанию.

<syntaxhighlight lang="python">>>> try:
...    raise Exception('spam', 'eggs')
... except Exception as inst:
...    print(type(inst))     # экземпляр исключения
...    print(inst.args)      # аргументы хранятся в .args
...    print(inst)           # __str__ позволяет вывести args явно,
...                          # но может быть переопределён в подклассах исключения
...    x, y = inst           # распаковка args
...    print 'x =', x
...    print 'y =', y
...
<class 'Exception'>
('spam', 'eggs')
('spam', 'eggs')
x = spam
y = eggs</syntaxhighlight>

Если у исключения есть аргументы, они выводится в качестве последней («детальной») части сообщения о необработанном исключении.

Обработчики исключений перехватывают не только исключения, появившиеся прямо в блоке <code>try</code>, но также и возбужденные внутри функций, которые были в блоке <code>try</code> вызваны (даже неявно). Например:

<syntaxhighlight lang="python">>>> def this_fails():
...     x = 1/0
... 
>>> try:
...     this_fails()
... except ZeroDivisionError as err:
...     print('Перехват ошибки времени исполнения:', err)
... 
Перехват ошибки времени исполнения: integer division or modulo by zero</syntaxhighlight>

=== Порождение исключений ===

Оператор <code>raise</code> позволяет программисту принудительно породить исключение. Например:

<syntaxhighlight lang="python">>>> raise NameError('ПриветТам')
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
NameError: ПриветТам</syntaxhighlight>

Единственный аргумент оператора <code>raise</code> определяет исключение, которое нужно возбудить. Им может быть либо экземпляр исключения, либо класс исключения (класс, дочерний к классу <code>Exception</code>).

Если вам нужно определить, было ли возбуждено исключение, не перехватывая его — упрощённая форма оператора <code>raise</code> позволит возбудить исключение заново:

<syntaxhighlight lang="python">>>> try:
...     raise NameError('ПриветТам')
... except NameError:
...     print('Исключение пролетело мимо!')
...     raise
...
Исключение пролетело мимо!
Traceback (most recent call last):
  File "<stdin>", line 2, in ?
NameError: ПриветТам</syntaxhighlight>

=== Исключения, определённые пользователем ===

В программах можно определять свои собственные исключения — посредством создания нового класса исключения. В общем случае, исключения должны быть унаследованы от класса <code>Exception</code>: явно или неявно. Например:

<syntaxhighlight lang="python">>>> class MyError(Exception):
...     def __init__(self, value):
...         self.value = value
...     def __str__(self):
...         return repr(self.value)
... 
>>> try:
...     raise MyError(2*2)
... except MyError as e:
...     print('Поймано моё исключение со значением:', e.value)
... 
Поймано моё исключение со значением: 4
>>> raise MyError('ой!')
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
__main__.MyError: 'ой!'</syntaxhighlight>

В этом примере был перегружен конструктор по умолчанию <code>__init__()</code> класса <code>Exception</code>. Новое поведение отличается лишь созданием нового атрибута <code>value</code> и заменяет поведение по умолчанию, при котором создаётся атрибут <code>args</code>.

Классы исключений могут определять любые действия, которые могут делать все другие классы. Однако, обычно их внутренняя структура довольно проста, и предоставляет лишь некоторые атрибуты, позволяющие обработчикам исключений выяснить информацию об ошибке подробно. При создании модуля, который может породить различные ошибки, обычной практикой будет создание базового класса для исключений, определённых в этом модуле, и подклассов для различных ошибочных состояний:

<syntaxhighlight lang="python">class Error(Exception):
    """Базовый класс для всех исключений в этом модуле."""
    pass

class InputError(Error):
    """Исключение порождается при ошибках при вводе.

    Атрибуты:
        expression -- выражение на вводе, в котором обнаружена ошибка
        message -- описание ошибки
    """

    def __init__(self, expression, message):
        self.expression = expression
        self.message = message

class TransitionError(Error):
    """Порождается, когда операция пытается выполнить неразрешённый переход
    из одного состояния в другое.

    Attributes:
        previous -- состояние в начале перехода
        next -- новое состояние, попытка принять которое была принята 
        message -- описание, по какой причине такой переход невозможен
    """

    def __init__(self, previous, next, message):
        self.previous = previous
        self.next = next
        self.message = message</syntaxhighlight>

Большинство исключений имеет имя, заканчивающееся на «<code>Error</code>», подобно стандартным исключениям.

Много стандартных модулей определяют собственные исключения, сообщающие об ошибках, которые могут появиться в определяющих их модулях. Больше информации о классах представлено в главе 1.10, [[Учебник Python 3.1#Классы|Классы]]

=== Определение действий при подчистке ===

У оператора <code>try</code> есть другой необязательный блок, предназначенный для операций подчистки, которые нужно выполнить независимо от условий:

<syntaxhighlight lang="python">>>> try:
...     raise KeyboardInterrupt
... finally:
...     print('Прощай, мир!')
... 
Прощай, мир!
Traceback (most recent call last):
  File "<stdin>", line 2, in ?
KeyboardInterrupt</syntaxhighlight>

''Блок <code>finally</code>'' исполняется всегда, когда интерпретатор покидает оператор <code>try</code>, независимо — были исключения или нет. Если в блоке <code>try</code> появилось исключение, которое не было обработано в блоке <code>except</code> (или появилось в самих блоках <code>except</code> или <code>else</code>) — оно порождается заново после выполнения блока <code>finally</code>. Также блок <code>finally</code> исполняется «по пути наружу», если какой-либо другой блок оператора <code>try</code> был покинут за счёт одного из операторов: <code>break</code>, <code>continue</code> или <code>return</code>. Более сложный пример:

<syntaxhighlight lang="python">>>> def divide(x, y):
...     try:
...         result = x / y
...     except ZeroDivisionError:
...         print("деление на ноль!")
...     else:
...         print("результат: ", result)
...     finally:
...         print("выполнение блока finally")
...
>>> divide(2, 1)
результат:  2
выполнение блока finally
>>> divide(2, 0)
деление на ноль!
выполнение блока finally
>>> divide("2", "1")
выполнение блока finally
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
  File "<stdin>", line 3, in divide
TypeError: unsupported operand type(s) for /: 'str' and 'str'</syntaxhighlight>

Как видите, блок <code>finally</code> выполняется при любом событии. Ошибка <code>TypeError</code> порождается при делении двух строк и не перехватывается блоком <code>except</code>, и поэтому порождается заново сразу после выполнения блока <code>finally</code>.

В приложениях реального мира, блок <code>finally</code> применяется для освобождения внешних ресурсов (таких как файлы или сетевые соединения), независимо от того, было ли их использование удачным.

=== Предопределённые действия по подчистке ===

Некоторые объекты определяют стандартные действия при подчистке, применяемые если объект больше не нужен, независимо от того, удачна была операция использования объекта или нет. Посмотрите на следующий пример, в которым мы пытаемся открыть файл и вывести его содержимое на экран.

<syntaxhighlight lang="python">for line in open("myfile.txt"):
    print(line)</syntaxhighlight>

Проблема этого кода в том, что он оставляет файл открытым на неопределённое количество времени после выполнения данной части кода. В простых сценариях это не является проблемой, но может стать ей в больших приложениях. Оператор <code>with</code> позволяет использовать объекты (такие как, например, файлы) таким образом, чтобы вы всегда могли быть уверены в том, что ресурсы будут сразу и корректно очищены.

<syntaxhighlight lang="python">with open("myfile.txt") as f:
    for line in f:
        print(line)</syntaxhighlight>

После выполнения оператора, файл ''<code>f</code>'' всегда закрывается, даже если при прочтении строк обнаружилась проблема. В документации к объектам, которые поддерживают предопределённые действия по подчистке, таким как файлы, эта их способность будет явно указана.

