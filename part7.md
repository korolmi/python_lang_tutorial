
== Модули ==

Если вы выйдете из интерпретатора и зайдёте в него снова, то все определённые вами имена (функции и переменные) будут потеряны. По этой причине, если вы захотите написать несколько более длинную программу, вам лучше использовать текстовый редактор для подготовки ввода для интерпретатора и запускать последний в режиме файлового ввода. Это называется созданием сценария. Если ваша программа становится обширнее, вы можете предпочесть разделить её на несколько файлов для удобства эксплуатации. Также вы можете захотеть использовать сразу в нескольких программах некоторую полезную функцию, написанную вами, не копируя её определение каждый раз.

В языке Python можно поместить требуемые определения в файл и использовать их в сценариях или в интерактивном режиме интерпретатора. Такой файл называется ''модулем'' (<tt>module</tt>). Определения из модуля могут быть импортированы в других модулях, либо в главном модуле (собрание переменных, к которым есть доступ в сценарии, который непосредственно запускается, и в интерактивном режиме).

Модуль — это файл, содержащий определения и операторы Python. Именем файла является имя модуля с добавленным суффиксом <tt>.py</tt>. Внутри модуля, имя модуля (в качестве строки) доступно в виде значения глобальной переменной с именем <code>__name__</code>. Например, используя ваш любимый текстовый редактор, создайте в текущем каталоге файл с именем <tt>fibo.py</tt> со следующим содержимым:

<syntaxhighlight lang="python">"""Модуль вычисления чисел Фибоначчи"""

def fib(n):    # вывести числа Фибоначчи вплоть до n
    a, b = 0, 1
    while b < n:
        print(b, end=' ')
        a, b = b, a+b
    print()

def fib2(n): # вернуть числа Фибоначчи вплоть до n
    result = []
    a, b = 0, 1
    while b < n:
        result.append(b)
        a, b = b, a+b
    return result</syntaxhighlight>

Теперь можно войти в интерпретатор Python и импортировать этот модуль следующей командой:

<syntaxhighlight lang="python">>>> import fibo</syntaxhighlight>

Это действие не переводит имена определённых в модуле функций в текущую таблицу символов, а лишь имя модуля <code>fibo</code>. Используя имя модуля, вы можете получить доступ к функциям:

<syntaxhighlight lang="python">>>> fibo.fib(1000)
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
>>> fibo.fib2(100)
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
>>> fibo.__name__
'fibo'</syntaxhighlight>

Если вы собираетесь использовать функцию часто, можно присвоить её локальному имени:

<syntaxhighlight lang="python">>>> fib = fibo.fib
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377</syntaxhighlight>

=== Подробнее о модулях ===

Помимо определений функций модуль может содержать исполняемые операторы. Назначение этих операторов — инициализация модуля: они выполняются при первом импортировании модуля где-либо<ref>Фактически, определения функций — те же «исполняемые» «операторы». Выполнение помещает имя функции в ''глобальную таблицу символов''.</ref>.

Каждый модуль имеет свою собственную ''таблицу символов'', которая используется в качестве глобальной всеми определёнными в модуле функциями. Таким образом, автор модуля может использовать глобальные символы в модуле, не опасаясь неожиданных совпадений с глобальными переменными пользователя. С другой стороны, если вы знаете, что делаете, можно сослаться на глобальные переменные модуля, пользуясь той же нотацией, которая применялась для ссылок на его функции: <tt>''&lt;имя_модуля>''.''&lt;имя_элемента>''</tt>.

Модули могут импортировать другие модули. Не требуется указывать все операторы <code>import</code> в начале модуля (или сценария, с той же целью), но обычно так и делается. Имена из импортированного модуля добавляются в ''глобальную таблицу символов'' модуля его импортирующего.

Есть вариант оператора <code>import</code>, который переносит имена из модуля прямо в таблицу символов импортирующего модуля. Например:

<syntaxhighlight lang="python">>>> from fibo import fib, fib2
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377</syntaxhighlight>

При этом имя самого модуля, из которого переносятся имена элементов, не добавляется в ''локальную таблицу символов'' (так, в этом примере, имя <code>fibo</code> не определено)

И есть даже способ импортировать все имена, которые определяет данный модуль:

<syntaxhighlight lang="python">>>> from fibo import *
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377</syntaxhighlight>

Импортируются все имена, кроме тех, которые начинаются на подчёркивание (<code>_</code>). В большинстве случаев программисты на Python не используют эту возможность, поскольку она внедряет в интерпретатор целый набор новых неизвестных имён и может скрыть некоторые объекты, которые вы уже определили.

{{Info2|Для повышения эффективности, каждый модуль импортируется лишь единожды за сеанс работы с интерпретатором. Поэтому, если вы изменили ваши модули, вам придётся перезапустить интерпретатор. Или, если вам нужно перезагрузить конкретный модуль, можно использовать <code>imp.reload()</code> таким образом: <code>import imp; imp.reload(<имя_модуля>)</code>}}

==== Выполнение модулей в качестве сценариев ====

Когда вы запускаете модуль Python в виде

<syntaxhighlight lang="python">python fibo.py <параметры></syntaxhighlight>

то код в этом модуле будет исполнен в момент его импортирования, но значением <code>__name__</code> будет строка <code>"__main__"</code>. Это значит, что добавляя следующий код в конец сценария:

<syntaxhighlight lang="python">if __name__ == "__main__":
    import sys
    fib(int(sys.argv[1]))</syntaxhighlight>

вы можете сделать возможным запуск файла и в качестве сценария, и в качестве импортируемого модуля. Это возможно, поскольку разбирающий командную строку код выполняется только при исполнении модуля как ''основного'' (<tt>main</tt>) файла:

<syntaxhighlight lang="python">$ python fibo.py 50
1 1 2 3 5 8 13 21 34</syntaxhighlight>

Если модуль импортируется, код не будет выполнен:

<syntaxhighlight lang="python">>>> import fibo
>>></syntaxhighlight>

Такой приём часто используется, чтобы предоставить удобный пользовательский интерфейс к модулю или для тестирования (выполнение модуля в качестве сценария запускает набор тестов).

==== Путь поиска модулей ====

Если импортируется модуль с именем <code>spam</code>, интерпретатор ищет файл с именем <tt>spam.py</tt> в текущем каталоге, а затем в каталогах, указанных в переменной окружения <code>PYTHONPATH</code>. У неё такой же синтаксис, как и у переменной шелла <code>PATH</code>, которая, в свою очередь, является перечислением каталогов. Когда переменная <code>PYTHONPATH</code> не установлена, или файл не найден в описанных в ней местах, поиск продолжается по пути по умолчанию, зависящему от указанного при установке; на Unix это обычно <tt>.:/usr/local/lib/python</tt>.

В действительности поиск модулей производится в списке каталогов в переменной <code>sys.path</code>, которая обычно содержит: каталог, в котором находится сценарий на входе (или текущий каталог), <code>PYTHONPATH</code> и умолчанием для каталога, указанного при установке. Это позволяет программам на Python (если программист знает, что делает) изменять или подменять путь поиска модулей. Заметьте: поскольку каталог, содержащий запускаемый вами сценарий, также находится в пути поиска, важно, чтобы в нем не было сценариев с именем стандартного модуля. Иначе, когда этот модуль будет импортироваться, Python будет пытаться загрузить в виде модуля сам сценарий, что в большинстве случаев вызовет ошибку. Для более подробной информации обратитесь к разделу [[Учебник Python 3.1#Стандартные модули|Стандартные модули]].

==== «Скомпилированные» файлы Python ====

Интерпретатор Python применяет один важный приём для ускорения запуска программы: если в каталоге, где располагается файл с некоторым модулем <tt>spam.py</tt>, находится также файл <tt>spam.pyc</tt>, предполагается, что это уже скомпилированная в байт-код («<tt>byte-compiled</tt>») версия модуля <code>spam</code>. В файле <tt>spam.pyc</tt> зафиксировано время изменения файла <tt>spam.py</tt> версии, использовавшейся для создания <tt>spam.pyc</tt>. Если версии не совпадают — файл <tt>.pyc</tt> игнорируется.

В обычном случае, вам не нужно ничего делать для создания файла <tt>spam.pyc</tt>. Каждый раз, когда <tt>spam.py</tt> успешно компилируется, предпринимается попытка записать скомпилированную версию в <tt>spam.pyc</tt>. Не считается ошибкой, если попытка неудачна: если по какой-либо причине файл не записан полностью, результирующий файл <tt>spam.pyc</tt> будет считаться некорректным и по этой причине в дальнейшем игнорироваться. Содержимое файла <tt>spam.pyc</tt> платформо-независимо, благодаря чему каталог модулей Python может использоваться параллельно машинами с различной архитектурой.

Несколько советов экспертам:

* Когда интерпретатор Python запускается с флагом <tt>'''-O'''</tt>, в файлах <tt>.pyo</tt> сохраняется сгенерированный оптимизированный код. На данный момент оптимизатор помогает не сильно — он лишь удаляет операторы <code>assert</code>. В случае использования <tt>'''-O'''</tt> оптимизируется весь ''байт-код'' (<tt>bytecode</tt>); файлы <tt>.pyc</tt> игнорируются, а файлы <tt>.py</tt> компилируются в оптимизированный байт-код.

* Передача двух флагов <tt>'''-O'''</tt> интерпретатору Python (<tt>'''-OO'''</tt>) принуждает компилятор байт-кода выполнять оптимизации, в редких случаях результат выполнения которых оказывается некачественно функционирующей программой. На данный момент из байт-кода удаляются только строки <code>__doc__</code>, в результате получаются более компактные файлы <tt>.pyo</tt>. Поскольку некоторые программы могут рассчитывать на их (строк) доступность, следует использовать эту возможность только в том случае, если вы знаете что делаете.

* Программа сама по себе не работает хоть сколь-нибудь быстрее, будучи прочитанной из файла <tt>.pyc</tt> или <tt>.pyo</tt>, чем если бы она была прочитана из файла <tt>.py</tt>. Единственный процесс, оказывающийся более быстрым при использовании файлов <tt>.pyc</tt> или <tt>.pyo</tt> — это скорость их подгрузки.

* Если сценарий запущен из командной строки, его байт-код никогда не будет записан в файл <tt>.pyc</tt> или <tt>.pyo</tt>. Таким образом, время запуска сценария может быть уменьшено за счёт перемещения большей части его кода в модули или использования небольшого загрузочного сценария, импортирующего этот модуль. Кроме того, можно указывать файл <tt>.pyc</tt> или <tt>.pyo</tt> прямо в командной строке.

* Можно иметь в наличии файл с именем <tt>spam.pyc</tt> (или <tt>spam.pyo</tt>, когда используется <tt>'''-O'''</tt>), не имея файла <tt>spam.py</tt> для того же модуля. Таким образом можно распространять библиотеки кода Python в том виде, из которого трудно восстановить исходный код.

* Модуль <tt>[[Справочник по библиотеке Python 3.1#compileall|compileall]]</tt> может создать файлы <tt>.pyc</tt> (или файлы <tt>.pyo</tt>, когда используется <tt>'''-O'''</tt>) для всех модулей в каталоге.

=== Стандартные модули ===

Python поставляется с библиотекой стандартных модулей, описанной в отдельном документе, [[Справочник по библиотеке Python 3.1|Справочнике по библиотеке Python]] (далее — «Справочнику по библиотеке»). Некоторые модули встроены в интерпретатор. Они обеспечивают доступ к операциям, не входящим в ядро языка, и встроены для большей эффективности и предоставления доступа к основным средствам операционной системы, таким как ''системные вызовы'' (<tt>system calls</tt>). Набор таких модулей — выбор настройки, зависимый от используемой платформы. Например, модуль <code>winreg</code> предоставляется только на системах с Windows. Один конкретный модуль заслуживает большего внимания: модуль <tt>[[Справочник по библиотеке Python 3.1#sys|sys]]</tt>, встроенный в каждую версию интерпретатора Python. Переменные <code>sys.ps1</code> и <code>sys.ps2</code> определяют строки, использующиеся в качестве основного и вспомогательного приглашений:

<syntaxhighlight lang="python">>>> import sys
>>> sys.ps1
'>>> '
>>> sys.ps2
'... '
>>> sys.ps1 = "Вводите: "
Вводите: print('Ох!')
Ох!
Вводите:
</syntaxhighlight>

Эти две переменные определены только для интерактивного режима интерпретатора.

Переменная <code>sys.path</code> представляет собой список строк, определяющий путь поиска модулей интерпретатора. Она инициализируется значением пути по умолчанию, взятым из переменной окружения <tt>PYTHONPATH</tt>, или встроенным значением по умолчанию, если <tt>PYTHONPATH</tt> не установлен. Вы можете изменить её значение, используя стандартные операции со списками:

<syntaxhighlight lang="python">>>> import sys
>>> sys.path.append('/ufs/guido/lib/python')</syntaxhighlight>

=== Функция <code>dir()</code> ===

Встроенная функция <code>dir()</code> используется для получения имён, определённых в модуле. Она возвращает отсортированный список строк:

<syntaxhighlight lang="python">>>> import fibo, sys
>>> dir(fibo)
['__name__', 'fib', 'fib2']
>>> dir(sys)
['__displayhook__', '__doc__', '__excepthook__', '__name__', '__stderr__',
 '__stdin__', '__stdout__', '_getframe', 'api_version', 'argv', 
 'builtin_module_names', 'byteorder', 'callstats', 'copyright',
 'displayhook', 'exc_info', 'excepthook',
 'exec_prefix', 'executable', 'exit', 'getdefaultencoding', 'getdlopenflags',
 'getrecursionlimit', 'getrefcount', 'hexversion', 'maxint', 'maxunicode',
 'meta_path', 'modules', 'path', 'path_hooks', 'path_importer_cache',
 'platform', 'prefix', 'ps1', 'ps2', 'setcheckinterval', 'setdlopenflags',
 'setprofile', 'setrecursionlimit', 'settrace', 'stderr', 'stdin', 'stdout',
 'version', 'version_info', 'warnoptions']</syntaxhighlight>

Будучи использованной без аргументов, функция <code>dir()</code> возвращает список имён, определённых в данный момент.

<syntaxhighlight lang="python">>>> a = [1, 2, 3, 4, 5]
>>> import fibo
>>> fib = fibo.fib
>>> dir()
['__builtins__', '__doc__', '__file__', '__name__', 'a', 'fib', 'fibo', 'sys']</syntaxhighlight>

Обратите внимание, что список состоит из имён всех типов: переменных, модулей, функций и т. д.

В возвращаемом функцией <code>dir()</code> списке не содержится встроенных функций и переменных. Если вы хотите получить ''их'' список, то они определены в стандартном модуле <code>builtins</code>:

<syntaxhighlight lang="python">>>> import builtins
>>> dir(builtins)
['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'Buffer
Error', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Excep
tion', 'False', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError
', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'KeyError',
 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'NameError', 'None', 'NotImp
lemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecatio
nWarning', 'ReferenceError', 'RuntimeError', 'RuntimeWarning', 'StopIteration',
'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'True',
 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', '
UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueE
rror', 'Warning', 'ZeroDivisionError', '__build_class__', '__debug__', '__doc__'
, '__import__', '__name__', 'abs', 'all', 'any', 'basestring', 'bin', 'bool', 'b
uffer', 'bytes', 'chr', 'chr8', 'classmethod', 'cmp', 'compile', 'complex', 'cop
yright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'ex
ec', 'exit', 'filter', 'float', 'frozenset', 'getattr', 'globals', 'hasattr', 'h
ash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', '
len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'o
bject', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr
', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'st
r', 'str8', 'sum', 'super', 'trunc', 'tuple', 'type', 'vars', 'zip']</syntaxhighlight>

=== Пакеты ===

Пакеты — способ структурирования ''пространств имён'' (<tt>namespaces</tt>) модулей Python за счёт использования имён модулей, разделённых точками («<tt>dotted module names</tt>»). Например, имя модуля <code>A.B</code> означает — подмодуль<ref>''(Прим. перев.)'' ''подмодуль'' (<tt>submodule</tt>), ''зд.'' — модуль, находящийся в пакете. ''подпакет'' (<tt>subpackage</tt>), ''зд.'' — пакет, расположенный в пакете.</ref> с именем <code>B</code> в пакете с именем <code>A</code>. Так же как использование модулей позволяет авторам различных модулей не заботиться о пересекающихся именах среди глобальных переменных, использование именования через точку позволяет авторам многомодульных пакетов (таких как <tt>NumPy</tt> или <tt>Python Imaging Library</tt>) не заботиться о конфликтах имён модулей.

Допустим, вы собираетесь разработать набор модулей (''пакет'', <tt>package</tt>) для унифицированной работы со звуковыми файлами и звуковыми данными. Существует множество форматов звуковых файлов (обычно их можно распознать по расширению, например: <tt>.wav</tt>, <tt>.aiff</tt>, <tt>.au</tt>). Таким образом, вам может понадобиться создать и поддерживать разрастающуюся коллекцию модулей для конвертирования между различными форматами файлов. Также вам наверняка захочется иметь побольше операций для обработки звуковых данных (таких как смешивание, добавление эха, применение функции эквалайзера, создание искусственного стерео-эффекта), поэтому в дополнение к этому вы будете писать нескончаемый поток модулей для исполнения этих операций. Вот возможная структура вашего пакета (выраженная в терминологии иерархической файловой системы):

<pre style="color:#00008b;">sound/                          Пакет верхнего уровня
      __init__.py               Инициализация пакета работы со звуком (sound)
      formats/                  Подпакет для конвертирования форматов файлов
              __init__.py
              wavread.py        (чтение wav)
              wavwrite.py       (запись wav)
              aiffread.py       (чтение aiff)
              aiffwrite.py      (запись aiff)
              auread.py         (чтение au)
              auwrite.py        (запись au)
              ...
      effects/                  Подпакет для звуковых эффектов
              __init__.py
              echo.py           ( эхо )
              surround.py       ( окружение )
              reverse.py        ( обращение )
              ...
      filters/                  Подпакет для фильтров
              __init__.py
              equalizer.py      ( эквалайзер )
              vocoder.py        ( вокодер ) 
              karaoke.py        ( караоке )
              ...</pre>

При импорте пакета Python ищет подкаталог пакета в каталогах, перечисленных в <code>sys.path</code>.

Файлы <tt>__init__.py</tt> необходимы для того, чтобы Python трактовал эти каталоги как содержащие пакеты. Это сделано во избежание нечаянного сокрытия правомерных модулей, встречающихся в дальнейшем по пути поиска, каталогами с часто используемыми именами, таким как «<code>string</code>». В наипростейшем случае файл <tt>__init__.py</tt> может быть пустым, но в более сложных может содержать код инициализации пакета или устанавливать значение описанной ниже переменной <code>__all__</code>.

Пользователи пакета могут импортировать из него конкретные модули, например:

<syntaxhighlight lang="python">import sound.effects.echo</syntaxhighlight>

Таким образом подгружается подмодуль <code>sound.effects.echo</code>. Ссылаться на него нужно используя его полное имя:

<syntaxhighlight lang="python">sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)</syntaxhighlight>

Другой способ импортирования подмодуля:

<syntaxhighlight lang="python">from sound.effects import echo</syntaxhighlight>

Так тоже подгружается подмодуль <code>echo</code>, но теперь он доступен без префикса пакета, поэтому может использоваться следующим образом:

<syntaxhighlight lang="python">echo.echofilter(input, output, delay=0.7, atten=4)</syntaxhighlight>

И еще один вариант — прямое импортирование желаемой функции или переменной:

<syntaxhighlight lang="python">from sound.effects.echo import echofilter</syntaxhighlight>

Опять же, таким образом подгружается подмодуль <code>echo</code>, но теперь его функция <code>echofilter()</code> может быть вызвана непосредственно:

<syntaxhighlight lang="python">echofilter(input, output, delay=0.7, atten=4)</syntaxhighlight>

Заметьте, что при использовании выражения <code>from ''пакет'' import ''элемент''</code>, ''элементом'' может быть подмодуль (или подпакет) пакета или любое другое имя, определённое в пакете — например, функция, класс или переменная. Оператор <code>import</code> сначала проверяет, определён ли элемент в пакете; если нет — он трактует его как модуль и пытается загрузить. Если не удается его найти, порождается исключение <code>ImportError</code>.

Напротив, при использовании синтаксиса в стиле <code>import ''элемент''.''подэлемент''.''подэлемент''</code>, все элементы кроме последнего должны быть пакетами; последний элемент может быть модулем или пакетом, но не может быть классом, функцией или переменной, определёнными в предыдущем элементе.

==== Импорт <code>*</code> из пакета ====

Что происходит, когда пользователь пишет <code>from sound.effects import *</code> ? В идеале, мы бы надеялись, что таким образом код выходит в файловую систему и находит какие подмодули существуют в пакете, импортируя их все. К сожалению, такой метод не очень хорошо работает на платформах Windows, поскольку у файловой системы не всегда есть корректная информация о регистре имён файлов. На этих платформах нет гарантированного способа узнать, нужно ли импортировать файл <tt>ECHO.PY</tt> в качестве модуля <code>echo</code>, <code>Echo</code> или <code>ECHO</code>. (Например, у Windows 95 есть назойливая привычка показывать имена всех файлов с заглавной буквы.) Ограничение DOS на имя файла в формате 8+3 добавляет забавную проблему, связанную с длинными именами модулей.

Единственный выход для автора пакета — предоставить его подробное содержание. Оператор <code>import</code> использует следующее соглашение: если в коде файла <tt>__init__.py</tt> текущего пакета определён список <code>__all__</code>, то он полагается списком имён модулей, которые нужно импортировать в случае <code>from ''пакет'' import *</code>. На совести автора поддержка этого списка в соответствующем состоянии в каждой новой версии пакета. Впрочем, авторы пакета могут его не поддерживать вообще, если не видят смысла в импортировании <code>*</code> из их пакета. Например, файл <code>sounds/effects/__init__.py</code> может содержать следующий код:

<syntaxhighlight lang="python">__all__ = ["echo", "surround", "reverse"]</syntaxhighlight>

Это будет значить, что выражение <code>from sound.effects import *</code> импортирует три именованных подмодуля из пакета <code>sound</code>.

Если список <code>__all__</code> не определён, оператор <code>from Sound.Effects import *</code> не импортирует все подмодули пакета <code>sound.effects</code> в текущее пространство имён: он лишь убеждается, что импортирован пакет <code>sound.effects</code> (возможно, выполняя код инициализации из <tt>__init__.py</tt>), а затем импортирует все определённые в пакете имена. В этот список попадают любые имена, определённые (и загруженные явно подмодулями) в <tt>__init__.py</tt>. В него также попадают все явно загруженные предшествующими операторами <code>import</code> подмодули. Рассмотрим следующий код:

<syntaxhighlight lang="python">import sound.effects.echo
import sound.effects.surround
from sound.effects import *</syntaxhighlight>

В этом примере модули <code>echo</code> и <code>surround</code> импортируются в текущее пространство имён, поскольку они определены в пакете <code>sound.effects</code> на тот момент, когда исполняется оператор <code>from ... import</code>. (И это также работает если определён <code>__all__</code>.)

Обратите внимание, что в общем случае импортирование <code>*</code> из модуля не приветствуется, поскольку в результате часто получается плохо-читаемый код. Однако, вполне нормально использовать его в интерактивных сессиях, чтобы меньше печатать, а определённые модули разработаны для экспорта только тех имён, которые следуют определённым шаблонам.

Помните: в использовании <code>from ''пакет'' import ''определённый_подмодуль''</code> нет ничего плохого. На самом деле — это рекомендованная запись, до тех пор пока при импортировании модуля не нужно использовать подмодули с одинаковым именем из разных пакетов.

==== Ссылки внутри пакета ====

Когда пакеты структурированы в подпакеты (например, в случае пакета <code>sound</code>), для того, чтобы сослаться на пакеты-потомки вы можете использовать абсолютное импортирование (<tt>absolute imports</tt>). Например, если модуль <code>sound.filters.vocoder</code> нуждается в модуле <code>echo</code> из пакета <code>sound.effects</code>, он должен использовать <code>from sound.effects import echo</code>.

Вы можете также использовать ''относительное импортирование'' (<tt>relative imports</tt>), применяя следующую форму оператора <code>import</code>: <code>from ''модуль'' import ''имя''</code> . При таком способе импортирования для описания текущего и родительского пакетов используется символ точки. Например, для модуля <code>surround</code> вы можете написать:

<syntaxhighlight lang="python">from . import echo
from .. import formats
from ..filters import equalizer</syntaxhighlight>

Обратите внимание, что относительное импортирование основано на имени текущего модуля. Поскольку имя главного модуля всегда «<code>__main__</code>», модули, предназначенные для использования в качестве главных модулей приложения на Python, должны всегда использовать ''абсолютное импортирование'' (<tt>absolute imports</tt>).

==== Пакеты в нескольких каталогах ====

Пакеты поддерживают ещё один специальный аттрибут: <code>__path__</code>. Перед исполнением файла <tt>__init__.py</tt> этого пакета, он инициализируется списком, содержащим имя каталога, в котором этот файл находится. Изменив переменную, можно повлиять на ход поиска модулей и подпакетов, содержащихся в пакете.

Хотя эта возможность нужна не так часто, она может быть использована для расширения набора модулей, находящихся в пакете.

