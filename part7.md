
== Модули ==

Если вы выйдете из интерпретатора и зайдёте в него снова, то все определённые вами имена (функции и переменные) будут потеряны. По этой причине, если вы захотите написать несколько более длинную программу, вам лучше использовать текстовый редактор для подготовки ввода для интерпретатора и запускать последний в режиме файлового ввода. Это называется созданием сценария. Если ваша программа становится обширнее, вы можете предпочесть разделить её на несколько файлов для удобства эксплуатации. Также вы можете захотеть использовать сразу в нескольких программах некоторую полезную функцию, написанную вами, не копируя её определение каждый раз.

В языке Python можно поместить требуемые определения в файл и использовать их в скриптах или в интерактивном режиме интерпретатора. Такой файл называется ''модулем'' (<tt>module</tt>). Определения из модуля могут быть импортированы в других модулях, либо в главном модуле (наборе переменных, к которым есть доступ в скрипте, который непосредственно запускается в интерактивном режиме).

Модуль — это файл, содержащий определения и операторы Python. Именем файла является имя модуля с добавленным суффиксом <tt>.py</tt>. Внутри модуля, имя модуля (в качестве строки) доступно в виде значения глобальной переменной с именем <code>__name__</code>. Например, с помощью механизма <tt>heredoc</tt> создадим в текущем каталоге файл с именем <tt>fibo.py</tt> со следующим содержимым:

<syntaxhighlight lang="python">%%bash
cat > fibo.py <<EOF
# Модуль вычисления чисел Фибоначчи

def fib(n):    # вывести числа Фибоначчи вплоть до n
    a, b = 0, 1
    while b < n:
        print(b, end=' ')
        a, b = b, a+b
    print()

def fib2(n): # вернуть числа Фибоначчи вплоть до n
    result = []
    a, b = 0, 1
    while b < n:
        result.append(b)
        a, b = b, a+b
    return result
EOF</syntaxhighlight>

Теперь можно войти в интерпретатор Python и импортировать этот модуль следующей командой:

<syntaxhighlight lang="python">>>> import fibo</syntaxhighlight>

Это действие не переводит имена определённых в модуле функций в текущую таблицу символов, в таблицу символов попадет лишь имя модуля <code>fibo</code>. Используя имя модуля, вы можете получить доступ к функциям:

<syntaxhighlight lang="python">>>> fibo.fib(1000)
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
>>> fibo.fib2(100)
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
>>> fibo.__name__
'fibo'</syntaxhighlight>

Если вы собираетесь использовать функцию часто, можно присвоить её локальному имени:

<syntaxhighlight lang="python">>>> fib = fibo.fib
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377</syntaxhighlight>

=== Подробнее о модулях ===

Помимо определений функций модуль может содержать исполняемые операторы. Назначение этих операторов — инициализация модуля: они выполняются один раз при первом импортировании модуля где-либо.

Каждый модуль имеет свою собственную ''таблицу символов'', которая используется в качестве глобальной всеми определёнными в модуле функциями. Таким образом, автор модуля может использовать глобальные символы в модуле, не опасаясь неожиданных совпадений с глобальными переменными пользователя. С другой стороны, если вы знаете, что делаете, можно сослаться на глобальные переменные модуля, пользуясь той же нотацией, которая применялась для ссылок на его функции: <tt>''&lt;имя_модуля>''.''&lt;имя_элемента>''</tt>.

Модули могут импортировать другие модули. Не требуется указывать все операторы <code>import</code> в начале модуля (или сценария, с той же целью), но обычно так и делается. Имена из импортированного модуля добавляются в ''глобальную таблицу символов'' модуля его импортирующего.

Есть вариант оператора <code>import</code>, который переносит имена из модуля прямо в таблицу символов импортирующего модуля. Например:

<syntaxhighlight lang="python">>>> from fibo import fib, fib2
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377</syntaxhighlight>

При этом имя самого модуля, из которого переносятся имена элементов, не добавляется в ''локальную таблицу символов'' (так, в этом примере, имя <code>fibo</code> не определено)

И есть даже способ импортировать все имена, которые определяет данный модуль:

<syntaxhighlight lang="python">>>> from fibo import *
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377</syntaxhighlight>

Импортируются все имена, кроме тех, которые начинаются на подчёркивание (<code>_</code>). В большинстве случаев программисты на Python не используют эту возможность, поскольку она внедряет в интерпретатор целый набор новых неизвестных имён и может скрыть некоторые объекты, которые вы уже определили.

Заметим, что в-целом практика импортирования ''*'' из модуля или пакета не является рекомендуемой, так как часто она порождает плохо читаемый код. Однако ее можно использовать для сокращения ввода во время интерактивных сессий.

Если имя модуля сопровоздается ключевым словом ''as'', то имя, следующее за этим словом ''as'' связывается  с проимпортированным модулем.

<syntaxhighlight lang="python">>>> import fibo as fib
>>> fib.fib(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377</syntaxhighlight>

Это то же самое, что произойдет при выполнении ''import fibo'', только модуль ''fibo'' теперь будет доступен как ''fib''.

Слово ''as'' можно использовать с ключевым словом ''from'', эффект будет похожим:

<syntaxhighlight lang="python">>>> from fibo import fib as fibonacci
>>> fibonacci(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377</syntaxhighlight>

Для повышения эффективности, каждый модуль импортируется лишь единожды за сеанс работы с интерпретатором. Поэтому, если вы изменили ваши модули, вам придётся перезапустить интерпретатор. Или, если вам нужно перезагрузить конкретный модуль, можно использовать <code>imp.reload()</code> таким образом: <code>import imp; imp.reload(<имя_модуля>)</code>

==== Выполнение модулей в качестве скриптов ====

Когда вы запускаете модуль Python в виде

<code>python fibo.py <параметры></code>

то код в этом модуле будет исполнен в момент его импортирования, но значением <code>__name__</code> будет строка <code>"__main__"</code>. Это значит, что добавляя следующий код в конец скрипта:

<code>if __name__ == "__main__":
    import sys
    fib(int(sys.argv[1]))
</code>

<syntaxhighlight lang="python">%%bash
cat > fibo.py <<EOF
# Модуль вычисления чисел Фибоначчи

def fib(n):    # вывести числа Фибоначчи вплоть до n
    a, b = 0, 1
    while b < n:
        print(b, end=' ')
        a, b = b, a+b
    print()

def fib2(n): # вернуть числа Фибоначчи вплоть до n
    result = []
    a, b = 0, 1
    while b < n:
        result.append(b)
        a, b = b, a+b
    return result

if __name__ == "__main__":
    import sys
    fib(int(sys.argv[1]))</syntaxhighlight>

вы можете сделать возможным запуск файла и в качестве скрипта, и в качестве импортируемого модуля. Это возможно, поскольку разбирающий командную строку код выполняется только при исполнении модуля как ''основного'' (<tt>main</tt>) файла:

<syntaxhighlight lang="python">!python fibo.py 50</syntaxhighlight>

Если модуль импортируется, код не будет выполнен:

<syntaxhighlight lang="python">>>> import fibo
>>></syntaxhighlight>

Такой приём часто используется, чтобы предоставить удобный пользовательский интерфейс к модулю или для тестирования (выполнение модуля в качестве сценария запускает набор тестов).

==== Путь поиска модулей ====

Если импортируется модуль с именем <code>spam</code>, интерпретатор сначала ищет встроенный модуль с таним именем. Если модуль не найден, он ищет файл с именем <tt>spam.py</tt> в каталогах, указанных в переменной 
<code>sys.path</code>. <code>sys.path</code> инициализируется из следующих путей:

* директория, содержащая скрипт (или текущая директория, если файл со скриптом не указан)
* переменная окружения <code>PYTHONPATH</code>. У неё такой же синтаксис, как и у переменной шелла <code>PATH</code>
* зависящее от конкретной установки python значение по умолчанию

Заметим, что в файловых системах, поддерживающих символические линки, директории, содержащая скрипт, вычисляется после перехода по символической ссылке. Другими словами, директория, содержащая символический линк не будет добавлена в путь поиска модулей. 

После инициализации программы на Python могут изменять <code>sys.path</code>. Заметьте: поскольку каталог, содержащий запускаемый вами сценарий, также находится в пути поиска, важно, чтобы в нем не было сценариев с именем стандартного модуля. Иначе, когда этот модуль будет импортироваться, Python будет пытаться загрузить в виде модуля сам сценарий, что в большинстве случаев вызовет ошибку. Для более подробной информации обратитесь к разделу [[Учебник Python 3.1#Стандартные модули|Стандартные модули]].

==== «Скомпилированные» файлы Python ====

Интерпретатор Python кэширует скомпилированную версию каждого модуля в директории ''__pycahe__'' в файле с именем <code>module.{version}.pyc</code>, здесь ''version'' обозначает формат скомпилированного файла; обычно в ней содержится номер версии Python. Например, для релиза 3.3 CPython скомпилированная версия файла <tt>spam.py</tt> будет закэширована в файле ''__pycache__/spam.cpython-33.pyc''. Это соглашение об именовании позволяет сосуществовать скомпилированным разными релизами и версиями Python модулям.

Python сравнивает дату модификации исходного файла с его скомпилированной версией для того, чтобы решить - нужна ли компиляция. Это - полностью автоматический процесс. Также заметим, что скомпилированные модули являются платформо-независимыми, поэтому одна и та же библиотека может быть использована системами с различными архитектурами.

Python не производит проверку кэша в двух обстоятельствах. Во-первых, всегда производится рекомпиляция без сохранения результата для модуля, загруженного непосредственно из командной строки. Во-вторых, кэш не проверяется, если нет исходного модуля. Для поддержки распределения модулей без исходного кода (только скомпилированные версии) скомпилированный модуль должен находиться в исходной директории, в которой не должно быть исходного модуля. 

Несколько советов экспертам:

* Вы можете вызвать интерпретатор Python с флагами <tt>-O</tt> или <tt>-OO</tt> для сокращени яразмера скомпилированного модуля. Флаг <tt>-O</tt> приводит к удалению из кода операторов <code>assert</code>, <tt>-OO</tt> удаляет из кода операторы <code>assert</code> и строки <code>__doc__</code>. Поскольку некоторые программы могут рассчитывать на их (строк) доступность, следует использовать эту возможность только в том случае, если вы знаете что делаете. "Оптимизированные" модули имеют префикс ''opt-'' и обычно меньший размер. Будущие релизы могут изменить эффекты оптимизации.

* Программа сама по себе не работает хоть сколь-нибудь быстрее, будучи прочитанной из файла <tt>.pyc</tt>, чем если бы она была прочитана из файла <tt>.py</tt>. Единственный процесс, оказывающийся более быстрым при использовании файлов <tt>.pyc</tt> — это скорость их загрузки.

* Модуль <tt>[[Справочник по библиотеке Python 3.1#compileall|compileall]]</tt> может создать файлы <tt>.pyc</tt> для всех модулей в каталоге.

* Детали этого процесса, включая диаграмму принятия решений, можно найти в PEP-3147.

=== Стандартные модули ===

Python поставляется с библиотекой стандартных модулей, описанной в отдельном документе, [[Справочник по библиотеке Python 3.1|Справочнике по библиотеке Python]] (далее — «Справочнику по библиотеке»). Некоторые модули встроены в интерпретатор. Они обеспечивают доступ к операциям, не входящим в ядро языка, и встроены для большей эффективности и предоставления доступа к основным средствам операционной системы, таким как ''системные вызовы'' (<tt>system calls</tt>). Набор таких модулей — выбор настройки, зависимый от используемой платформы. Например, модуль <code>winreg</code> предоставляется только на системах с Windows. Один конкретный модуль заслуживает большего внимания: модуль <tt>[[Справочник по библиотеке Python 3.1#sys|sys]]</tt>, встроенный в каждую версию интерпретатора Python. Переменные <code>sys.ps1</code> и <code>sys.ps2</code> определяют строки, использующиеся в качестве основного и вспомогательного приглашений:

<syntaxhighlight lang="python">>>> import sys
>>> sys.ps1
>>> sys.ps2
>>> sys.ps1 = "Вводите: "</syntaxhighlight>

Эти две переменные определены только для интерактивного режима интерпретатора.

Переменная <code>sys.path</code> представляет собой список строк, определяющий путь поиска модулей интерпретатора. Она инициализируется значением пути по умолчанию, взятым из переменной окружения <tt>PYTHONPATH</tt>, или встроенным значением по умолчанию, если <tt>PYTHONPATH</tt> не установлен. Вы можете изменить её значение, используя стандартные операции со списками:

<syntaxhighlight lang="python">>>> import sys
>>> sys.path.append('/ufs/guido/lib/python')</syntaxhighlight>

=== Функция <code>dir()</code> ===

Встроенная функция <code>dir()</code> используется для получения имён, определённых в модуле. Она возвращает отсортированный список строк:

<syntaxhighlight lang="python">>>> import fibo, sys
>>> dir(fibo)
['__name__', 'fib', 'fib2']
>>> dir(sys)  # doctest: +NORMALIZE_WHITESPACE
['__breakpointhook__', '__displayhook__', '__doc__', '__excepthook__',
'__interactivehook__', '__loader__', '__name__', '__package__', '__spec__',
'__stderr__', '__stdin__', '__stdout__', '__unraisablehook__',
'_clear_type_cache', '_current_frames', '_debugmallocstats', '_framework',
'_getframe', '_git', '_home', '_xoptions', 'abiflags', 'addaudithook',
'api_version', 'argv', 'audit', 'base_exec_prefix', 'base_prefix',
'breakpointhook', 'builtin_module_names', 'byteorder', 'call_tracing',
'callstats', 'copyright', 'displayhook', 'dont_write_bytecode', 'exc_info',
'excepthook', 'exec_prefix', 'executable', 'exit', 'flags', 'float_info',
'float_repr_style', 'get_asyncgen_hooks', 'get_coroutine_origin_tracking_depth',
'getallocatedblocks', 'getdefaultencoding', 'getdlopenflags',
'getfilesystemencodeerrors', 'getfilesystemencoding', 'getprofile',
'getrecursionlimit', 'getrefcount', 'getsizeof', 'getswitchinterval',
'gettrace', 'hash_info', 'hexversion', 'implementation', 'int_info',
'intern', 'is_finalizing', 'last_traceback', 'last_type', 'last_value',
'maxsize', 'maxunicode', 'meta_path', 'modules', 'path', 'path_hooks',
'path_importer_cache', 'platform', 'prefix', 'ps1', 'ps2', 'pycache_prefix',
'set_asyncgen_hooks', 'set_coroutine_origin_tracking_depth', 'setdlopenflags',
'setprofile', 'setrecursionlimit', 'setswitchinterval', 'settrace', 'stderr',
'stdin', 'stdout', 'thread_info', 'unraisablehook', 'version', 'version_info',
'warnoptions']</syntaxhighlight>

Будучи использованной без аргументов, функция <code>dir()</code> возвращает список имён, определённых в данный момент.

<syntaxhighlight lang="python">>>> a = [1, 2, 3, 4, 5]
>>> import fibo
>>> fib = fibo.fib
>>> dir()
['__builtins__', '__name__', 'a', 'fib', 'fibo', 'sys']</syntaxhighlight>

Обратите внимание, что список состоит из имён всех типов: переменных, модулей, функций и т. д.

В возвращаемом функцией <code>dir()</code> списке не содержится встроенных функций и переменных. Если вы хотите получить ''их'' список, то они определены в стандартном модуле <code>builtins</code>:

<syntaxhighlight lang="python">>>> import builtins
>>> dir(builtins)  # doctest: +NORMALIZE_WHITESPACE
['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException',
'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning',
'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError',
'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning',
'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False',
'FileExistsError', 'FileNotFoundError', 'FloatingPointError',
'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError',
'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError',
'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError',
'MemoryError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented',
'NotImplementedError', 'OSError', 'OverflowError',
'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError',
'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning',
'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError',
'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError',
'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError',
'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning',
'ValueError', 'Warning', 'ZeroDivisionError', '_', '__build_class__',
'__debug__', '__doc__', '__import__', '__name__', '__package__', 'abs',
'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable',
'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits',
'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit',
'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr',
'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass',
'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview',
'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property',
'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice',
'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars',
'zip']</syntaxhighlight>

=== Пакеты ===

Пакеты — способ структурирования ''пространств имён'' (<tt>namespaces</tt>) модулей Python за счёт использования имён модулей, разделённых точками («<tt>dotted module names</tt>»). Например, имя модуля <code>A.B</code> означает — подмодуль с именем <code>B</code> в пакете с именем <code>A</code>. Так же как использование модулей позволяет авторам различных модулей не заботиться о пересекающихся именах среди глобальных переменных, использование именования через точку позволяет авторам многомодульных пакетов (таких как <tt>NumPy</tt> или <tt>Python Imaging Library</tt>) не заботиться об имён модулей в других пакетах.

Допустим, вы собираетесь разработать набор модулей (''пакет'', <tt>package</tt>) для унифицированной работы со звуковыми файлами и звуковыми данными. Существует множество форматов звуковых файлов (обычно их можно распознать по расширению, например: <tt>.wav</tt>, <tt>.aiff</tt>, <tt>.au</tt>). Таким образом, вам может понадобиться создать и поддерживать разрастающуюся коллекцию модулей для конвертирования между различными форматами файлов. Также вам наверняка захочется иметь побольше операций для обработки звуковых данных (таких как смешивание, добавление эха, применение функции эквалайзера, создание искусственного стерео-эффекта), поэтому в дополнение к этому вы будете писать нескончаемый поток модулей для исполнения этих операций. Вот возможная структура вашего пакета (выраженная в терминологии иерархической файловой системы):

<pre style="color:#00008b;">sound/                          Пакет верхнего уровня
      __init__.py               Инициализация пакета работы со звуком (sound)
      formats/                  Подпакет для конвертирования форматов файлов
              __init__.py
              wavread.py        (чтение wav)
              wavwrite.py       (запись wav)
              aiffread.py       (чтение aiff)
              aiffwrite.py      (запись aiff)
              auread.py         (чтение au)
              auwrite.py        (запись au)
              ...
      effects/                  Подпакет для звуковых эффектов
              __init__.py
              echo.py           ( эхо )
              surround.py       ( окружение )
              reverse.py        ( обращение )
              ...
      filters/                  Подпакет для фильтров
              __init__.py
              equalizer.py      ( эквалайзер )
              vocoder.py        ( вокодер ) 
              karaoke.py        ( караоке )
              ...</pre>

При импорте пакета Python ищет подкаталог пакета в каталогах, перечисленных в <code>sys.path</code>.

Файлы <tt>__init__.py</tt> необходимы для того, чтобы Python трактовал эти каталоги как содержащие пакеты. Это сделано во избежание нечаянного сокрытия правомерных модулей, встречающихся в дальнейшем по пути поиска, каталогами с часто используемыми именами, таким как «<code>string</code>». В наипростейшем случае файл <tt>__init__.py</tt> может быть пустым, но в более сложных может содержать код инициализации пакета или устанавливать значение описанной ниже переменной <code>__all__</code>.

Пользователи пакета могут импортировать из него конкретные модули, например:

<code>import sound.effects.echo</code>

Таким образом подгружается подмодуль <code>sound.effects.echo</code>. Ссылаться на него нужно используя его полное имя:

<code>sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)</code>

Другой способ импортирования подмодуля:

<code>from sound.effects import echo</code>

Так тоже подгружается подмодуль <code>echo</code>, но теперь он доступен без префикса пакета, поэтому может использоваться следующим образом:

<code>echo.echofilter(input, output, delay=0.7, atten=4)</code>

И еще один вариант — прямое импортирование желаемой функции или переменной:

<code>from sound.effects.echo import echofilter</code>

Опять же, таким образом подгружается подмодуль <code>echo</code>, но теперь его функция <code>echofilter()</code> может быть вызвана непосредственно:

<code>echofilter(input, output, delay=0.7, atten=4)</code>

Заметьте, что при использовании выражения <code>from ''пакет'' import ''элемент''</code>, ''элементом'' может быть подмодуль (или подпакет) пакета или любое другое имя, определённое в пакете — например, функция, класс или переменная. Оператор <code>import</code> сначала проверяет, определён ли элемент в пакете; если нет — он трактует его как модуль и пытается загрузить. Если не удается его найти, порождается исключение <code>ImportError</code>.

Напротив, при использовании синтаксиса в стиле <code>import ''элемент''.''подэлемент''.''подэлемент''</code>, все элементы кроме последнего должны быть пакетами; последний элемент может быть модулем или пакетом, но не может быть классом, функцией или переменной, определёнными в предыдущем элементе.

==== Импорт <code>*</code> из пакета ====

Что происходит, когда пользователь пишет <code>from sound.effects import *</code> ? В идеале, мы бы надеялись, что таким образом код выходит в файловую систему и находит какие подмодули существуют в пакете, импортируя их все. Это может выполняться достаточно долго, импорт подмодулей может иметь нежелательные побочные эффекты, которые должны случаться только при явном импорте подмодулей.

Единственный выход для автора пакета — предоставить его подробное содержание. Оператор <code>import</code> использует следующее соглашение: если в коде файла <tt>__init__.py</tt> текущего пакета определён список <code>__all__</code>, то он полагается списком имён модулей, которые нужно импортировать в случае <code>from ''пакет'' import *</code>. На совести автора поддержка этого списка в соответствующем состоянии в каждой новой версии пакета. Впрочем, авторы пакета могут его не поддерживать вообще, если не видят смысла в импортировании <code>*</code> из их пакета. Например, файл <code>sounds/effects/__init__.py</code> может содержать следующий код:

<code>__all__ = ["echo", "surround", "reverse"]</code>

Это будет значить, что выражение <code>from sound.effects import *</code> импортирует три перечисленных в списоке подмодуля из пакета <code>sound</code>.

Если список <code>__all__</code> не определён, оператор <code>from Sound.Effects import *</code> **не** импортирует все подмодули пакета <code>sound.effects</code> в текущее пространство имён: он лишь убеждается, что импортирован пакет <code>sound.effects</code> (возможно, выполняя код инициализации из <tt>__init__.py</tt>), а затем импортирует все определённые в пакете имена. В этот список попадают любые имена, определённые (и загруженные явно подмодулями) в <tt>__init__.py</tt>. В него также попадают все явно загруженные предшествующими операторами <code>import</code> подмодули пакета. Рассмотрим следующий код:

<code>
import sound.effects.echo
import sound.effects.surround
from sound.effects import *
</code>

В этом примере модули <code>echo</code> и <code>surround</code> импортируются в текущее пространство имён, поскольку они определены в пакете <code>sound.effects</code> на тот момент, когда исполняется оператор <code>from ... import</code>. (И это также работает если определён <code>__all__</code>.)

Обратите внимание, что в общем случае импортирование <code>*</code> из модуля не приветствуется, поскольку в результате часто получается плохо-читаемый код. Однако, вполне нормально использовать его в интерактивных сессиях, чтобы меньше печатать, 

Хотя определённые модули разработаны для экспорта только тех имён, которые следуют определённым шаблонам при использовании <code>import *</code>, его использование считается плохой практикой для продуктивного кода.

Помните: в использовании <code>from ''пакет'' import ''определённый_подмодуль''</code> нет ничего плохого. На самом деле — это рекомендованный подход для тех случаев, когда при импортировании модуля не нужно использовать подмодули с одинаковым именем из разных пакетов.

==== Ссылки внутри пакета ====

Когда пакеты структурированы в подпакеты (например, в случае пакета <code>sound</code>), для того, чтобы сослаться на пакеты-потомки вы можете использовать абсолютное импортирование (<tt>absolute imports</tt>). Например, если модуль <code>sound.filters.vocoder</code> нуждается в модуле <code>echo</code> из пакета <code>sound.effects</code>, он может использовать <code>from sound.effects import echo</code>.

Вы можете также использовать ''относительное импортирование'' (<tt>relative imports</tt>), применяя следующую форму оператора <code>import</code>: <code>from ''модуль'' import ''имя''</code> . При таком способе импортирования для описания текущего и родительского пакетов используется префикс из символов "точка". Например, для модуля <code>surround</code> вы можете написать:

<code>
from . import echo
from .. import formats
from ..filters import equalizer
</code>

Обратите внимание, что относительное импортирование основано на имени текущего модуля. Поскольку имя главного модуля всегда «<code>__main__</code>», модули, предназначенные для использования в качестве главных модулей приложения на Python, должны всегда использовать ''абсолютное импортирование'' (<tt>absolute imports</tt>).

==== Пакеты в нескольких каталогах ====

Пакеты поддерживают ещё один специальный аттрибут: <code>__path__</code>. Перед исполнением файла <tt>__init__.py</tt> пакета, он инициализируется списком, содержащим имя каталога, в котором этот файл находится. Изменив переменную, можно повлиять на ход поиска модулей и подпакетов, содержащихся в пакете.

Хотя эта возможность нужна не так часто, она может быть использована для расширения набора модулей, находящихся в пакете.