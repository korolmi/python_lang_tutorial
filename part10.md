
== Классы ==

За счёт механизма классов Python в язык с минимальным использованием нового синтаксиса и семантики добавляется возможность создания классов. Это смесь классовых механизмов, заимствованных из C++ и Modula-3. Как и в случае модулей, классы в Python не устанавливают абсолютного барьера между определением и программистом, рассчитывая больше на аккуратность и вежливость последнего — чтобы он не «врывался в определения». Наиболее важные возможности классов, тем не менее, содержат в себе всю возможную мощь: механизм наследования классов поддерживает несколько предков для класса, производный класс может переопределять любые методы своего предка или предков, а любой его метод может вызвать метод предка с таким же именем. Объекты могут содержать произвольное количество закрытых (<tt>private</tt>) данных.

В терминологии C++, члены класса (включая данные-члены), обычно, открыты (<tt>public</tt>) (исключая [[Учебник Python 3.1#Приватные переменные|Приватные переменные]], описанные ниже), а все функции-члены — виртуальны. Нет специальных конструкторов и деструкторов. Как в Modula-3, нет краткой ссылки на члены объекта из его методов: функция-метод определяется с явным первым аргументом, описывающим объект, который неявно передаётся при вызове. Как в Smalltalk, классы сами по себе являются объектами, хотя и в более широком смысле: в Python все типы данных — объекты. Таким образом обеспечивается семантика для импортирования и переименования. В отличие от C++ и Modula-3 встроенные типы могут использоваться в качестве предков для расширения возможностей пользователем. Кроме того, как в C++, но не как в Modula-3, большинство встроенных операторов со специальным синтаксисом (арифметические операторы, индексирование и т. д.) могут быть переопределены для экземпляров классов.

=== Пара слов о терминологии ===

Обходя стороной поддерживаемую всем миром терминологию, применимую к разговорам о классах, в нашем случае я буду говорить в терминах C++ и Smalltalk. (Предпочёл бы использовать термины языка Modula-3, поскольку Python ближе к ней по объектно-ориентированной семантике, чем к C++, но предполагаю, что немногие читатели слышали о нём.)

Объекты обладают индивидуальностью, и с одним объектом может быть связано несколько имён (в нескольких областях видимости). Такая практика в других языках известна как ''совмещение имён'' (<tt>aliasing</tt>). На первый взгляд, совмещение малозаметно в Python, и его можно без последствий игнорировать при работе с основными неизменяемыми типами (числами, строками, кортежами). Тем не менее, совмещение имён влияет на семантику программного кода Python, работающего с изменяемыми объектами: списками, словарями и большинством типов, описывающих сущности вне программы (файлы, окна и т. п.). Обычно такая практика считается полезной, поскольку псевдонимы работают подобно указателям и вероятно даже превосходят их возможности. Например, передача объекта — дешевая операция, поскольку по реализации передаётся только указатель. Если функция изменяет переданный в качестве аргумента объект, это будет заметно и в месте вызова. За счёт этого пропадает необходимость в двух различных механизмах передачи аргументов.

=== Области видимости и пространства имён в Python ===

Прежде чем заняться классами необходимо получить представление о правилах областей видимости в Python. Определения классов проделывают над пространствами имён некоторые ловкие трюки. Чтобы полностью понимать происходящее, нужно знать о принципах работы областей видимости и пространств имён. Эти знания не помешают любому профессиональному программисту на Python.

Давайте начнём с нескольких определений.

''Пространство имён'' (<tt>namespace</tt>) — это набор связей имён с объектами<ref>''(Прим. перев.) A namespace is a mapping from names to objects {{ref-en}} — ''(букв.)'' пространство имён суть отображение имён на объекты''</ref>. В настоящий момент большинство пространств имён реализованы в виде словарей Python, но не стоит заострять на этом внимание (если только по поводу производительности): возможно, в будущем реализация изменится. Примеры пространств имён: набор встроенных имён (функции вроде <code>abs()</code> и имён встроенных исключений); глобальные имена в модуле; локальные имена при вызове функции. Важная вещь, которую необходимо знать о пространствах имён — это то, что нет абсолютно никакой связи между именами в разных пространствах имён: например, два разных модуля могут без проблем определять функцию «<code>maximize</code>», так как пользователи модулей будут использовать имена модулей в качестве префиксов.

Кстати, слово ''атрибут'' (<tt>attribute</tt>) я применяю к любому имени, следующему за точкой. Например, в выражении <code>z.real</code>, <code>real</code> — это атрибут объекта <code>z</code>. Строго говоря, ссылки на имена в модуле являются ссылками на атрибуты: в выражении <code>''имя_модуля''.''имя_функции''</code> под ''имя_модуля'' скрывается объект модуля, а под ''имя_функции'' — его атрибут. В таком случае обнаруживается прямая связь между атрибутами модуля и глобальными именами, определёнными в модуле: они разделяют между собой одно и тоже пространство имён<ref>Исключая одну тонкость. У объектов модулей есть скрытый, только для чтения, атрибут под именем <code>__dict__</code>, возвращающий словарь, использовавшийся для формирования пространства имён модуля; имя <code>__dict__</code> является атрибутом, но не глобальным именем. Очевидно, что всё это нарушает абстракцию реализации пространства имён и его использование следует ограничить вещами вроде посмертных отладчиков</ref>.

Запись в атрибуты может быть запрещена (''атрибут только для чтения'', <tt>read-only attribute</tt>) или разрешена (''перезаписываемый атрибут'', <tt>writable attribute</tt>). В последнем случае присваивание атрибуту является возможным. Атрибуты модуля перезаписываемы: вы можете написать «<code>modname.the_answer = 42</code>»<ref>''(Прим. перев.)'' Снова [[w:ru:Ответ на главный вопрос жизни, вселенной и всего такого|ответ на главный вопрос жизни, вселенной и всего такого]]</ref>. Перезаписываемые атрибуты могут также быть удалены оператором <code>del</code>. Например, код «<code>del modname.the_answer</code>» удалит атрибут <code>the_answer</code> из объекта с именем <code>modname</code>.

Пространства имён создаются в различные моменты и имеют разное время жизни. Пространство имён, содержащее встроенные имена создаётся при запуске интерпретатора и не удаляется никогда. Глобальное пространство имён модуля создаётся при вычитке определения модуля. Обычно, пространства имён модулей также «живут» до выхода из интерпретатора. Выражения, выполняемые верхне-уровневым порождением интерпретатора, прочитанные из файла сценария или интерактивно, рассматриваются как часть модуля под названием <code>__main__</code>, поэтому у них есть своё собственное глобальное пространство имён. (Встроенные имена по факту также живут в модуле, он называется <code>builtins</code>).

Локальное пространство имён функции создаётся при её вызове и удаляется когда функция возвращает значение либо порождает исключение, внутри неё не перехваченное. (На самом деле, лучшим способом объяснить, что происходит на самом деле, было бы «забывание»). Конечно же, рекурсивные порождения имеют свои пространства имён каждое.

''Область видимости'' (<tt>scope</tt>) — это текстовая область в программе на Python, из которой прямым образом доступно пространство имён. «Прямым образом доступно» подразумевает, что явная ссылка на имя вынуждает интерпретатор искать это имя в пространстве имён.

Несмотря на то, что области видимости определяются статически, используются они динамически. В любой момент во время выполнения существует как минимум три вложенных области видимости, чьи пространства имён доступны прямым образом: самая внутренняя<ref>''(Прим. перев.)'' ''Innermost scope'', ''outermost scope'' {{ref-en}} — самая внутренняя и самая внешняя области видимости</ref> область видимости (по ней поиск осуществляется в первую очередь) содержит локальные имена; пространства имён всех объемлющих [данный код] функций, поиск по которым начинается с ближайшей объемлющей [код] области видимости; область видимости среднего уровня, по ней следующей проходит поиск и она содержит глобальные имена текущего модуля; и самая внешняя область видимости (заключительный поиск) — это пространство имён, содержащее встроенные имена.

Если имя определено глобально, тогда все ссылки и присваивания уходят прямо в область видимости среднего уровня, содержащую глобальные имена модуля. Чтобы сменить привязку у всех переменных, найденных вне самой внутренней области видимости, можно использовать оператор <code>nonlocal</code>; если такая переменная не объявлена как <code>nonlocal</code>, то она используется только для чтения (попытка записать значение в такую переменную создаст новую локальную переменную в самой внутренней области видимости, оставляя идентично названную вовне переменную без изменений).

Обычно локальная область видимости ссылается на локальные имена текущей (на уровне текста) функции. Вне функций локальная область видимости ссылается на то же пространство имён, что и глобальная область видимости: пространство имён модуля. Определения классов помещают в локальную область видимости ещё одно пространство имён.

Важно осознавать, что области видимости ограничиваются на текстовом уровне: глобальная область видимости функции, определённая в модуле, является пространством имён этого модуля, независимо от того, откуда или по какому псевдониму была эта функция вызвана. С другой стороны, фактический поиск имён осуществляется динамически, во время выполнения. Как бы то ни было, язык развивается в сторону статического разрешения имён (во время компиляции), так что не стоит полагаться на динамическое разрешение имён. (Фактически, локальные переменные уже определены статично.)

Особая хитрость в Python состоит в том, что — при условии, что в данной области не включены операторы <code>global</code> или <code>nonlocal</code> — присваивания именам всегда уходят в самую внутреннюю область видимости. Присваивания не копируют данных, а лишь связывают имена с объектами. То же самое верно и для удалений: оператор «<code>del x</code>» удаляет связь <code>x</code> из пространства имён, на которое ссылается локальная область видимости. В действительности, все операции, вводящие новые имена, используют локальную область видимости: в частности, операторы импорта и описаний функций связывают имя модуля или функции в локальной области видимости соответственно. (Для того, чтобы указать определённой переменной, что она должна быть расположена в глобальной области видимости, может использоваться оператор <code>global</code>.)

Оператор <code>global</code> можно использовать для того, чтобы объявить определённые переменные как привязанные к глобальной области видимости и указывает, что их переназначения должны происходить в ней; оператор <code>nonlocal</code> помечает переменные как привязанные к окружающей их области видимости и указывает, что их переназначения должны происходить в ней.

=== Пример по областям видимости и пространствам имён ===

Приведём пример, показывающий, каким образом можно ссылаться на разные области видимости и пространства имён и как <code>global</code> и <code>nonlocal</code> влияют на привязку переменной.

<syntaxhighlight lang="python">def scope_test():
    def do_local():
        spam = "локальный спам"
    def do_nonlocal():
        nonlocal spam
        spam = "нелокальный спам"
    def do_global():
        global spam
        spam = "глобальный спам"

    spam = "тестовый спам"
    do_local()
    print("После локального присваивания:", spam)
    do_nonlocal()
    print("После нелокального присваивания:", spam)
    do_global()
    print("После глобального присваивания:", spam)

scope_test()
print("В глобальной области видимости:", spam)</syntaxhighlight>

Вывод кода из примера таков:

<syntaxhighlight lang="text">После локального присваивания: тестовый спам
После нелокального присваивания: нелокальный спам
После глобального присваивания: нелокальный спам
В глобальной области видимости: глобальный спам</syntaxhighlight>

Заметьте, что локальное присваивание (работающее по умолчанию) не заменяет глобальную привязку на связывание из <code>scope_test</code>. Нелокальное присваивание заменило глобальную привязку на связывание из <code>scope_test</code>, а глобальное присваивание заменило привязку на связывание на уровне модуля.

Можно увидеть, что до глобального присваивания у переменной <code>spam</code> не было предшествующих связываний.

=== Первый взгляд на классы ===

В описании классов представлено немного нового синтаксиса, три новых типа объектов<ref>''(Прим. перев.)'' ''Class Objects'', ''Instance Objects'', ''Method Objects'' {{ref-en}} — объекты классов, объекты экземпляров, объекты методов; по тексту перевода, хоть и могут восприниматься непривычно, используются термины «объекты-классы», «объекты-экземпляры» и «объекты-методы» — ввиду того, что словосочетание «объект класса» может обозначать и принадлежность объекта классу</ref> и некоторое количество новой семантики.

==== Синтаксис определения класса ====

Простейшая форма определения класса выглядит так:

<syntaxhighlight lang="python">class ИмяКласса:
    <оператор-1>
    .
    .
    .
    <оператор-N>
</syntaxhighlight>

Определения классов, как и определения функций (операторы <code>def</code>), должны быть исполнены для того, чтобы определить действие. (Вы можете, предположим, поместить определение класса в ветку оператора <code>if</code> или внутрь функции.)

На практике, внутри определения класса обычно помещаются определения функций, но позволено использовать и другие операторы — и иногда с пользой — как мы увидим позже. Определения функций внутри класса имеют особенную форму списка аргументов, в связи с соглашениями по вызову методов — опять же, это будет рассмотрено ниже.

При вводе определения класса создаётся новое пространство имён, которое и используется в качестве локальной области видимости. Таким образом, все присваивания локальным переменным происходят в этом новом пространстве имён. В частности, определения функций связываются здесь с именами новых функций.

При успешном окончании парсинга определения класса (по достижении конца определения), создаётся ''объект-класс'' (<tt>class object</tt>). По существу, это обёртка вокруг содержимого пространства имён, созданного во время определения класса; подробнее объекты классов мы изучим в следующем разделе. Оригинальная локальная область видимости (та, которая действовала в последний момент перед вводом определения класса) восстанавливается, а объект-класс тут же связывается в ней с именем класса, указанном в заголовке определения класса (в примере — ''<code>ИмяКласса</code>'').

==== Объекты-классы ====

Объекты-классы поддерживают два вида операций: ссылки на атрибуты и создание экземпляра.

''Ссылки на атрибуты'' (<tt>Attribute references</tt>) используют стандартный синтаксис, использующийся для всех ссылок на атрибуты в Python: <code>''объект''.''имя''</code>. Корректными именами атрибутов являются все имена, которые находились в пространстве имён класса при создании объекта-класса. Таким образом, если определение класса выглядело так:

<syntaxhighlight lang="python">class MyClass:
    """Простой пример класса"""
    i = 12345
    def f(self):
        return 'привет мир'</syntaxhighlight>

то <code>MyClass.i</code> и <code>MyClass.f</code> являются корректными ссылками на атрибуты, возвращающими целое и ''объект-функцию'' (<tt>function object</tt>) соответственно. Атрибутам класса можно присваивать значение, так что вы можете изменить значение <code>MyClass.i</code> через присваивание. <code>__doc__</code> также является корректным атрибутом, возвращающим строку документации, принадлежащей классу: <code>"Простой пример класса"</code>.

Создание экземпляра класса использует синтаксис вызова функции. Просто представьте, что объект-класс — это непараметризированная функция, которая возвращает новый экземпляр класса. Например (предполагая класс, приведённый выше):

<syntaxhighlight lang="python">x = MyClass()</syntaxhighlight>

создаёт новый экземпляр класса и присваивает этот объект локальной переменной <code>x</code>.

Операция ''создания экземпляра'' (<tt>instantiation</tt>) создаёт объект данного класса. Большая часть классов предпочитает создавать экземпляры, имеющие определённое начальное состояние. Для этого класс может определять специальный метод под именем <code>__init__()</code>, например так:

<syntaxhighlight lang="python">def __init__(self):
    self.data = []</syntaxhighlight>

Когда в классе определён метод <code>__init__()</code>, при создании экземпляра автоматически вызывается <code>__init__()</code> нового, только что созданного объекта. Так, в этом примере, новый инициализированный экземпляр может быть получен за счёт выполнения кода:

<syntaxhighlight lang="python">x = MyClass()</syntaxhighlight>

Конечно же, для большей гибкости, метод <code>__init__()</code> может иметь параметры. В этом случае аргументы, переданные оператору создания экземпляра класса, передаются методу <code>__init__()</code>. Например,

<syntaxhighlight lang="python">>>> class Complex:
...     def __init__(self, realpart, imagpart):
...         self.r = realpart
...         self.i = imagpart
...
>>> x = Complex(3.0, -4.5)
>>> x.r, x.i
(3.0, -4.5)</syntaxhighlight>

==== Объекты-экземпляры ====

Теперь, что же мы можем делать с объектами-экземплярами? Единственные операции, доступные объектам-экземплярам — это ссылки на атрибуты. Есть два типа корректных имён атрибутов — это атрибуты-данные и методы.

''Атрибуты-данные'' (<tt>data attributes</tt>) аналогичны «переменным экземпляров» в Smalltalk и «членам-данным» в C++. Атрибуты-данные не нужно описывать: как и переменные, они начинают существование в момент первого присваивания. Например, если <code>x</code> — экземпляр созданного выше <code>MyClass</code>, следующий отрывок кода выведет значение <code>16</code>, не вызвав ошибок:

<syntaxhighlight lang="python">x.counter = 1
while x.counter < 10:
    x.counter = x.counter * 2
print(x.counter)
del x.counter</syntaxhighlight>

Другой тип ссылок на атрибуты экземпляра — это ''метод'' (<tt>method</tt>). Метод — это функция, «принадлежащая» объекту. (В Python термин не уникален для экземпляров класса: другие объекты также могут иметь методы. Например, объекты-списки имеют методы <code>append</code>, <code>insert</code>, <code>remove</code>, <code>sort</code> и т. п. Тем не менее, ниже под термином «метод» мы будем понимать только методы объектов-экземпляров классов, пока отдельно не будет указано иное.)

Корректные имена методов объектов-экземпляров зависят от их класса. По определению, все атрибуты класса, являющиеся объектами-функциями, описывают соответствующие методы его экземпляров. Так, в нашем примере, <code>x.f</code> является корректной ссылкой на метод, а <code>x.i</code> ей не является, поскольку не является и <code>MyClass.i</code>. Но при этом <code>x.f</code> — это не то же самое, что <code>MyClass.f</code>: это объект-метод, а не объект-функция.

==== Объекты-методы ====

Обычно, метод вызывают сразу после его связывания [с функцией]:

<syntaxhighlight lang="python">x.f()</syntaxhighlight>

На примере <code>MyClass</code> такой код возвратит строку <code>'привет мир'</code>. Однако, не обязательно вызывать метод так уж сразу: <code>x.f</code> — это объект-метод, он может быть отложен и вызван когда-либо позже. Например:

<syntaxhighlight lang="python">xf = x.f
while True:
    print(xf())</syntaxhighlight>

будет печатать <code>'привет мир'</code> до конца времён.

Что конкретно происходит при вызове метода? Вы, возможно, заметили, что <code>x.f()</code> выше был вызван без аргументов, хотя в описании функции <code>f</code> аргумент был указан. Что же случилось с аргументом? Несомненно, Python порождает исключение когда функция, требующая присутствия аргумента, вызвана без единого — даже, если он на самом деле не используется…

Теперь вы, возможно, догадались: отличительная особенность методов состоит в том, что в качестве первого аргумента функции передаётся объект. В нашем примере вызов <code>x.f()</code> полностью эквивалентен вызову <code>MyClass.f(x)</code>. В общем случае, вызов метода со списком из ''n'' аргументов эквивалентен вызову соответствующей функции со списком аргументов, созданным за счёт вставки объекта, вызвавшего метод, перед первым аргументом.

Если вы всё ещё не поняли, как работают методы, взгляд на реализацию возможно прояснит происходящее. Когда атрибут экземпляра ссылается на что-либо, не являющееся атрибутом-данными, производится поиск по классу. Если имя указывает корректный атрибут класса, являющийся объектом-функцией, создаётся метод: через упаковку (указателя на) объекта-экземпляра и найденного объекта-функции в абстрактный объект, получается объект-метод. Когда объект-метод вызывается со списком аргументов, он снова распаковывается и новый список аргументов конструируется из объекта-экземпляра и оригинального списка аргументов, и затем уже с новым списком аргументов вызывается объект-функция.

=== Различные замечания ===

Атрибуты-данные переопределяют атрибуты-методы с тем же именем; для того, что обезопасить себя от случайных конфликтов имён, которые могут привести к трудно-обнаруживаемым ошибкам в больших программах, разумно использовать какое-нибудь соглашение, которое могло бы уменьшить шансы возникновения конфликтов. Возможные соглашения включают в себя: написание имён методов строчными буквами, предварение имени атрибутов-данных некоторой короткой уникальной строкой (предположим, лишь символом подчёркивания («<code>_</code>»)), или использование глаголов для именования методов и существительных для именования данных.

Методы могут ссылаться на атрибуты-данные также как и обычные пользователи («клиенты») объекта. Другими словами, классы не подходят для разработки чистых абстрактных типов данных. Фактически же в Python нет ничего, вынуждающего вас скрывать данные: сокрытие основано на соглашении между программистами. (С другой стороны, реализация Python, написанная на C, может полностью скрывать детали разработки и, если нужно, контролировать доступ к объекту, это можно делать в расширениях для Python, написанных на C.)

Клиенты должны использовать атрибуты-данные с осторожностью, так как иначе они могут нарушить инварианты, подразумеваемые методами класса при использовании атрибутов-данных. Заметьте, что обычно клиенты могут добавлять собственные атрибуты-данные к объектам-экземплярам, не нарушая работы методов, если не происходит конфликтов имён. Опять же, соглашение об именовании может избавить вас от головной боли и в этих случаях.

''(Прим. перев.)'' Автором здесь не упомянут механизм свойств (<tt>property</tt>). Свойство синтаксически является атрибутом-данным, но за кулисами с ним могут быть связаны отдельные методы для чтения, записи и удаления. Документация к функции-декоратору <code>property</code> хорошо проясняет суть дела:

<syntaxhighlight lang="python">>>> print(property.__doc__)
property(fget=None, fset=None, fdel=None, doc=None) -> property attribute

fget - функция для чтения, fset - для записи, fdel - для удаления атрибута.
Типичный пример использования для управляемого атрибута x:
class C(object):
    def getx(self): return self._x
    def setx(self, value): self._x = value
    def delx(self): del self._x
    x = property(getx, setx, delx, "Я - свойство 'x'.")

Декораторы упрощают определение новых свойств и изменение существующих:
class C(object):
    @property
    def x(self): return self._x
    @x.setter
    def x(self, value): self._x = value
    @x.deleter
    def x(self): del self._x
</syntaxhighlight>
''(Конец прим.)''

У методов нет краткой записи для ссылок изнутри на атрибуты-данные (и другие методы!). Я нахожу, что это и вправду повышает читабельность методов: нет шанса спутать локальные переменные и переменные экземпляров при просмотре тела метода.

Обычно, первый аргумент метода называется <code>self</code>. Это не более чем соглашение: имя <code>self</code> не имеет абсолютно никакого специального смысла для языка Python. (Однако, обратите внимание, что если вы не следуете соглашениям, ваш код может стать менее читабелен для других программистов; и также, потенциально, программа навигации по классам может опираться на такие соглашения.)

Любой объект-функция, являющийся атрибутом класса, определяет метод для экземпляров этого класса. Не так важно, чтобы текст определения функции был заключен в определение класса: присваивание объекта-функции локальной переменной класса также работает неплохо. Например:

<syntaxhighlight lang="python"># Функция, определённая вне класса
def f1(self, x, y):
    return min(x, x+y)

class C:
    f = f1
    def g(self):
        return 'привет мир'
    h = g</syntaxhighlight>

Теперь <code>f</code>, <code>g</code> и <code>h</code> — все являются атрибутами класса <code>C</code>, ссылающимися на объекты-функции, и следовательно, все они являются методами экземпляров <code>C</code> — <code>h</code> становится полностью эквивалентен <code>g</code>. Заметьте, что такая практика обычно лишь запутывает читателя программы.

Методы могут вызывать другие методы за счёт использования атрибутов-методов аргумента <code>self</code>:

<syntaxhighlight lang="python">class Bag:
    def __init__(self):
        self.data = []
    def add(self, x):
        self.data.append(x)
    def addtwice(self, x):
        self.add(x)
        self.add(x)</syntaxhighlight>

Методы могут ссылаться на глобальные имена таким же образом, как и обычные функции. Глобальная область видимости, связанная с методом — это модуль, содержащий определение класса. (Сам класс никогда не используется в качестве глобальной области видимости!) В то время, как одни редко находят причины для использования глобальных данных в методах, существует множество разумных причин использовать глобальную область видимости: для примера, функции и модули, импортированные в глобальную область видимости, могут использоваться в методах так же, как в функциях и классах, в ней определённых. Обычно класс, содержащий метод, сам определён в этой глобальной области видимости, и в следующем разделе мы найдём пару хороших причин, почему методу может быть необходимо ссылаться на собственный класс!

=== Наследование ===

Конечно же, не поддерживай «класс» наследование, не стоило бы называть его «классом». Синтаксис производного класса выглядит так:

<syntaxhighlight lang="python">class ИмяПроизводногоКласса(ИмяБазовогоКласса):
    <оператор-1>
    .
    .
    .
    <оператор-N></syntaxhighlight>

Имя ''<code>ИмяБазовогоКласса</code>'' должно быть определено в области видимости, содержащей определение производного класса. Вместо имени базового класса также позволяется использовать другие выражения. Это может быть полезно, например, когда базовый класс определён в другом модуле:

<syntaxhighlight lang="python">class ИмяПроизводногоКласса(имямодуля.ИмяБазовогоКласса):</syntaxhighlight>

Использование определения производного класса проходит таким же образом, как и базового. Базовый класс полностью сохраняется по завершению конструирования объекта-класса. Такой метод используется для разрешения ссылок на атрибуты<ref>''(Прим. перев.)'' ''Resolving attribute references'' {ref-en} — разрешение (поиск значений) ссылок на атрибуты</ref>: если запрошенный атрибут не был найден в самом классе, поиск продолжается в базовом классе. Правило применяется рекурсивно, если базовый класс сам является производным от некоторого другого класса.

В создании экземпляров производных классов нет ничего особенного: <code>ИмяПроизводногоКласса()</code> создаёт новый экземпляр класса. Ссылки на методы разрешаются следующим образом: производится поиск соответствующего атрибута класса (спускаясь вниз по цепочке базовых классов, если необходимо) и ссылка на метод считается корректной, если она порождает объект-функцию.

Производные классы могут перегружать методы своих базовых классов. Поскольку у методов нет особых привилегий при вызове других методов того же объекта, метод базового класса, вызывающий другой метод, определённый в этом же классе, может вызвать перегруженный метод производного класса. (Для программистов на C++: все методы в Python фактически виртуальны.)

При перегрузке метода в производном классе возможна не только замена действия метода базового класса с тем же именем, но и его расширение. Существует простой способ вызвать метод базового класса прямым образом: просто вызовите «<code>ИмяБазовогоКласса.имяметода(self, аргументы)</code>». Такой способ будет неожиданно полезным и для клиентов. (Обратите внимание, что он работает только если базовый класс определён и импортирован прямо в глобальную область видимости.)

В языке Python есть функции, которые работают с наследованием:

* Используйте <code>isinstance()</code> чтобы проверить тип объекта: <code>isinstance(obj, int)</code> возвратит <code>True</code> только если <code>obj.__class__</code> является <code>int</code> или некоторым классом, наследованным от <code>int</code>.
* Используйте <code>issubclass()</code> чтобы проверить наследственность класса: <code>issubclass(bool, int)</code> возвратит <code>True</code>, поскольку класс <code>bool</code> является наследником (<tt>subclass</tt>) <code>int</code>. Однако, <code>issubclass(float, int)</code> возвратит <code>False</code>, поскольку класс <code>float</code> не является наследником <code>int</code>.

==== Множественное наследование ====

Python также поддерживает форму ''множественного наследования'' (<tt>multiple inheritance</tt>). Определение класса с несколькими базовыми классами будет выглядеть так:

<syntaxhighlight lang="python">class ИмяПроизводногоКласса(Базовый1, Базовый2, Базовый3):
    <оператор-1>
    .
    .
    .
    <оператор-N></syntaxhighlight>

В простейших случаях и для большинства задач, вы можете представлять себе поиск атрибутов, наследованных от родительского класса в виде «сперва вглубь», затем «слева-направо». Таким образом, если атрибут не найден в ''<code>ИмяПроизводногоКласса</code>'', его поиск выполняется в ''<code>Базовом1</code>'', затем (рекурсивно) в базовых классах ''<code>Базового1</code>'' и только если он там не найден, поиск перейдёт в ''<code>Базовый2</code>'' и так далее.

На самом деле всё немного сложнее. Порядок разрешения методов<ref>''(Прим. перев.)'' другими словами — поиска корректной привязки для метода</ref> (<tt>method resolution order</tt>) меняется динамически, чтобы обеспечить возможность сотрудничающих вызовов <code>super()</code>. Этот способ известен в некоторых других языках с поддержкой множественного наследования как «вызов-следующего-метода» («<tt>call-next-method</tt>») и имеет больше возможностей, чем вызов родительского метода в языках с единичным наследованием.

Динамическое упорядочивание (<tt>dynamic ordering</tt>) имеет важность, поскольку все вариации множественного наследования проявляют в себе эффект ромбовых отношений (когда как минимум один родительский класс может быть доступен различными путями из низшего в иерархии класса). Например, все классы наследуются от <code>object</code>, так что множественное наследование в любом виде предоставляет более одного пути для того, чтобы достичь <code>object</code>. Чтобы защитить базовые классы от двойных и более запросов, динамический алгоритм «выпрямляет» (<tt>linearizes</tt>) порядок поиска таким образом, что тот сохраняет указанный слева-направо порядок для каждого класса, который вызывает каждый родительский класс только единожды и является монотонным (значит, класс можно сделать наследником, не взаимодействуя с порядком предшествования его родителей). Обобщённые вместе, эти свойства позволяют разрабатывать надёжные и расширяемые классы, используя множественное наследование. С подробностями можно ознакомиться по этой ссылке: http://www.python.org/download/releases/2.3/mro/ ([[Python — Порядок разрешения методов|перевод]]).

=== Приватные переменные ===

В Python имеется ограниченная поддержка идентификаторов, приватных для класса. Любой идентификатор в форме <code>__spam</code> (как минимум два предшествующих символа подчёркивания, как максимум один завершающий) заменяется дословно на <code>_classname__spam</code>, где <code>classname</code> — текущее имя класса, лишённое предшествующих символов подчёркивания. Это ''искажение'' (<tt>mangling</tt>) производится без оглядки на синтаксическую позицию идентификатора, поэтому может использоваться для определения переменных, приватных для класса экземпляров, переменных класса, методов, переменных в глобальной области видимости (<tt>globals</tt>), и даже переменных, использующихся в экземплярах, приватных для этого класса на основе экземпляров ''других'' классов. Имя может быть обрезано, если его длина превышает 255 символов. Вне классов, или когда имя состоит из одних символов подчёркивания, искажения не происходит.

Предназначение искажения имён состоит в том, чтобы дать классам лёгкую возможность определить «приватные» переменные экземпляров и методы, не беспокоясь о переменных экземпляров, определённых в производных классах, и о забивании кодом вне класса переменных экземпляров. Обратите внимание, что правила искажения имён разработаны, в основном, чтобы исключить неприятные случайности — решительная душа всё ещё может получить доступ или изменить переменные, предполагавшиеся приватными. В некотором особом окружении, таком как отладчик, это может оказаться полезным — и это единственная причина, по которой лазейка не закрыта. (Внимание: наследование класса с таким же именем как и у базового делает возможным использование приватных переменных базового класса.)

Заметьте, что код, переданный в <code>exec()</code> или <code>eval()</code>, не предполагает в качестве текущего имени класса имя класса, порождающего вызов — так же, как и в случае эффекта с оператором <code>global</code> — эффекта, который также ограничен для всего побайтно-компилирующегося кода. И, такое же ограничение применимо для функций <code>getattr()</code>, <code>setattr()</code> и <code>delattr()</code>, и также для прямой ссылки на <code>__dict__</code>.

=== Всякая всячина ===

Иногда бывает полезен тип данных, похожий на <code>record</code> из языка Pascal или <code>struct</code> из языка C, например, для хранения нескольких поименованных элементов данных. Для этой цели подойдет даже пустое определение класса<ref>''(Прим. перев.)'':<syntaxhighlight lang="python">class Рабочий:
    pass

джон = Рабочий() # Создать пустую запись о рабочем

# Заполнить поля записи
джон.имя = 'Джон До'
джон.отдел = 'компьютерная лаборатория'
джон.зарплата = 1000</syntaxhighlight></ref>:

<syntaxhighlight lang="python">class Employee:
    pass

john = Employee() # Создать пустую запись о рабочем

# Заполнить поля записи
john.name = 'John Doe'
john.dept = 'computer lab'
john.salary = 1000</syntaxhighlight>

Фрагменту кода на Python, требующему на входе некоторого абстрактного типа данных, можно дать экземпляр, эмулирующий методы этого типа данных. Например, если имеется функция, умеющая форматировать данные из файлового объекта, то можно определить класс с методами <code>read()</code> и <code>readline()</code> (работающие с данными, скажем, из строкового буфера) и передать ей экземпляр этого класса в качестве аргумента.

Объекты-методы экземпляров также имеют атрибуты: <code>m.__self__</code> — исходный объект-экземпляр с методом <code>m()</code>, а <code>m.__func__</code> — объект-функция, соответствующий методу.

=== Исключения — тоже классы ===

Исключения, определённые пользователем, могут быть также отождествлены с классами. При использовании этого механизма становится возможным создавать расширяемые иерархии исключений.

Оператор <code>raise</code> имеет следующие (синтаксически) правильные формы:

<syntaxhighlight lang="python">raise Класс

raise Экземпляр</syntaxhighlight>

В первой форме, ''<code>Класс</code>'' должен быть экземпляром типа или класса, производного от него. Первая форма является краткой записью следующего кода:

<syntaxhighlight lang="python">raise Class()</syntaxhighlight>

Класс в блоке <code>except</code> является сопоставимым с исключением, если является этим же классом или самим по себе базовым классом (никаких других способов обхода — описанный в блоке <code>except</code> производный класс не сопоставим с базовым). Например, следующий код выведет B, C, D в этом порядке:

<syntaxhighlight lang="python">class B(Exception):
    pass
class C(B):
    pass
class D(C):
    pass

for c in [B, C, D]:
    try:
        raise c()
    except D:
        print("D")
    except C:
        print("C")
    except B:
        print("B")</syntaxhighlight>

Обратите внимание, что если бы блоки <code>except</code> шли в обратном порядке (начиная с «<code>except B</code>»), код вывел бы B, B, B — сработал бы первый совпадающий блок <code>except</code>.

При выводе сообщения об ошибке о необработанном исключении, выводится класс исключения, затем двоеточие и пробел, и наконец экземпляр, приведённый к строке за счёт встроенной функции <code>str()</code>.

=== Итераторы ===

К этому моменту вы, возможно, заметили, что используя оператор <code>for</code> можно организовать цикл по большинству объектов-контейнеров:

<syntaxhighlight lang="python">for element in [1, 2, 3]:
    print(element)
for element in (1, 2, 3):
    print(element)
for key in {'один':1, 'два':2}:
    print(key)
for char in "123":
    print(char)
for line in open("myfile.txt"):
    print(line)</syntaxhighlight>

Такой стиль доступа к элементам прост, лаконичен и удобен. Использованием ''итераторов'' (<tt>iterators</tt>) пропитан язык Python, и это его выделяет среди других. Негласно, оператор <code>for</code> вызывает метод <code>iter()</code> объекта-контейнера. Функция возвращает объект итератора, который определяет метод <code>__next__()</code>, который по очереди получает доступ к элементам в контейнере, по одному за раз. Если больше не остаётся элементов, метод <code>__next__()</code> порождает исключение <code>StopIteration</code>, которое сообщает оператору <code>for</code> о необходимости завершения прохода. Вы можете вызывать метод <code>__next__()</code> посредством встроенной функции <code>next()</code>; следующий пример показывает, как это работает:

<syntaxhighlight lang="python">>>> s = 'абв'
>>> it = iter(s)
>>> it
<iterator object at 0x00A1DB50>
>>> next(it)
'а'
>>> next(it)
'б'
>>> next(it)
'в'
>>> next(it)

Traceback (most recent call last):
  File "<stdin>", line 1, in ?
    next(it)
StopIteration</syntaxhighlight>

Ознакомившись с механизмами, скрытыми за протоколом итераторов, легко добавить возможность итерирования к вашим классам. Определите метод <code>__iter__()</code>, который возвращает объект с методом <code>next()</code>. Если класс определяет и метод <code>next()</code>, тогда <code>__iter__()</code> может просто возвращать <code>self</code>.

<syntaxhighlight lang="python">class Reverse:
    "Итератор по последовательности в обратном направлении"
    def __init__(self, data):
        self.data = data
        self.index = len(data)
    def __iter__(self):
        return self
    def __next__(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.data[self.index]

>>> for char in Reverse('спам'):
...     print(char)
...
м
а
п
с</syntaxhighlight>

=== Генераторы ===

''Генераторы'' (<tt>generators</tt>) — простой и мощный инструмент для создания итераторов. Они записываются как обычная функция, но где бы им ни было необходимо вернуть данные, используется оператор <code>yield</code>. Каждый раз, когда над ним вызывается <code>__next__()</code>, генератор возвращается к месту, где он был оставлен (он запоминает все значения данных, а также какой оператор был выполнен последним). Пример показывает, что создание генераторов может быть тривиально простым:

<syntaxhighlight lang="python">def reverse(data):
    for index in range(len(data)-1, -1, -1):
        yield data[index]
	
>>> for char in reverse('гольф'):
...     print(char)
...
ф
ь
л
о
г</syntaxhighlight>

Всё, что можно сделать с использованием генераторов, может быть сделано с использованием основанных на итераторах классов, как описано в предыдущем разделе. Благодаря автоматическому созданию методов <code>__iter__()</code> и <code>next()</code> генераторы так компактны.

Другая важная особенность состоит в том, что между вызовами сохраняются локальные переменные и ''состояние выполнения'' (<tt>execution state</tt>). Это позволяет конструкциям функций быть проще, а получению переменных экземпляров быть намного легче, нежели с использованием <code>self.index</code> и <code>self.data</code>.

В дополнение к автоматическому созданию методов и сохранению состояния, когда генераторы заканчивают своё действие, они автоматически порождают исключение <code>StopIteration</code>. В комбинации, эти особенности позволяют легко создавать итераторы не прилагая усилий больших, чем нужно для написания обычной функции.

=== Выражения-генераторы ===

Некоторые простые генераторы могут быть сжато закодированы в выражении с использованием синтаксиса, схожего со ''списковыми сборками'', но с круглыми скобками вместо квадратных. Выражения-генераторы разработаны в основном для случаев, когда генератор тут же используется в качестве аргумента функции. Выражения с генераторами более компактные, но менее гибкие чем полные определения генераторов и обычно используют память экономнее, чем эквивалентные ''списковые сборки''.

Примеры<ref>''(Прим. перев.)'':<br />
<br />
<code>>>> ''сумма''(i*i '''для''' i '''в''' ''диапазон''(10))                 # сумма квадратов<br/>
285<br/>
<br/>
>>> вектор_а = [10, 20, 30]<br/>
>>> вектор_б = [7, 5, 3]<br/>
>>> ''сумма''(x*y '''для''' x,y '''в''' ''зип''(вектор_а, вектор_б))         # скалярное произведение<br/>
260<br/>
<br/>
>>> '''из''' матем '''импорт''' пи, ''синус''<br/>
>>> таблица_синусов = {x:  ''синус''(x*пи/180)) '''для''' x '''в''' ''диапазон''(0, 91)}<br/>
<br/>
>>> уникальные_слова = ''набор''(слово&nbsp;&nbsp;'''для''' строка '''в''' страница&nbsp;&nbsp;'''для''' слово '''в''' строка.''разбить''())<br/>
<br/>
>>> выпускники = ''макс''((студент.ср_балл, студент.имя) '''для''' студент '''в''' окончившие)<br/>
<br/>
>>> данные = 'гольф'<br/>
>>> ''список''(данные[i] '''для''' i '''в''' ''диапазон''(''длина''(данные)-1, -1, -1))<br/>
['ф', 'ь', 'л', 'о', 'г']</code></ref>:

<syntaxhighlight lang="python">>>> sum(i*i for i in range(10))                 # сумма квадратов
285

>>> xvec = [10, 20, 30]
>>> yvec = [7, 5, 3]
>>> sum(x*y for x,y in zip(xvec, yvec))         # скалярное произведение
260

>>> from math import sin, radians
>>> sine_table = {x: sin(radians(x)) for x in range(0, 91)}

>>> unique_words = set(word  for line in page  for word in line.split())

>>> valedictorian = max((student.gpa, student.name) for student in graduates)

>>> data = 'golf'
>>> list(data[i] for i in range(len(data)-1, -1, -1))
['f', 'l', 'o', 'g']</syntaxhighlight>

