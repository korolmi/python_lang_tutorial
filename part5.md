== Больше средств для управления потоком команд ==

Помимо описанного выше оператора <code>while</code>, в Python доступны привычные операторы управления потоком из других языков, но с некоторыми особенностями.

=== Оператор <code>if</code> ===

Возможно, наиболее широко известный тип оператора — оператор <code>if</code> (если). Пример:

<syntaxhighlight lang="python">>>> x = int(input("Введите, пожалуйста, целое число: "))
Введите, пожалуйста, целое число: 42
>>> if x < 0:
...      x = 0
...      print('Отрицательное значение, изменено на ноль')
... elif x == 0:
...      print('Ноль')
... elif x == 1:
...      print('Один')
... else:
...      print('Больше')
...</syntaxhighlight>

Блока <code>elif</code> может не быть вообще, он может быть один или их может быть несколько, а блок <code>else</code> (иначе) необязателен. Ключевое слово <tt>elif</tt> — краткая запись <tt>else if</tt> (иначе если) — позволяет избавиться от чрезмерного количества отступов. Оператор <code>if</code> <tt>...</tt> <code>elif</code> <tt>...</tt> <code>elif</code> <tt>...</tt> — аналог оператора выбора <code>switch</code> или <code>case</code>, которые можно встретить в других языках программирования.

Если вы сравниваете одно и то же значение с несколькими константами или проверяете конкретные типы или атрибуты, вам может пригодиться оператор <code>match</code>. Мы о нем расскажем чуть позже.

=== Операторы <code>for</code> ===

Оператор <code>for</code> в Python немного отличается от того, какой вы, возможно, использовали в C или Pascal. Вместо только прохождения по арифметической прогрессии из чисел (как в Pascal) или предоставления пользователю возможности указать шаг итерации и условие остановки (как в С), оператор <code>for</code> в Python проходит по всем элементам любой последовательности (списка или строки) в том порядке, в котором они в ней располагаются. Например:

<syntaxhighlight lang="python">>>> # Измерим несколько строк:
... a = ['cat', 'window', 'defenestrate']
>>> for x in a:
...     print(x, len(x))
...
cat 3
window 6
defenestrate 12</syntaxhighlight>

Изменять содержимое последовательности, по которой проходит цикл, достаточно сложно (в плане отладки). Если необходимо модифицировать последовательность, то лучше работать в цикле в ее копей.

<pre>
    # Создадим тестовый набор
    users = {'Hans': 'active', 'Éléonore': 'inactive', '景太郎': 'active'}

    # Подход:  проходим по копии
    for user, status in users.copy().items():
        if status == 'inactive':
            del users[user]

    # Подход:  создадим новый набор
    active_users = {}
    for user, status in users.items():
        if status == 'active':
            active_users[user] = status
</pre>

=== Функция <code>range()</code> ===

Если вам нужно перебрать последовательность чисел, встроенная функция <code>range()</code> придёт на помощь. Она генерирует арифметические прогрессии:

<syntaxhighlight lang="python">>>> for i in range(5):
...    print(i)
...
0
1
2
3
4</syntaxhighlight>

Заданный конец интервала никогда не включается в сгенерированный список; вызов <code>range(10)</code> генерирует десять значений, которые являются подходящими индексами для элементов последовательности длины 10. Можно указать другое начало интервала и другой, даже отрицательный инкремент (его иногда называют "шаг").

<pre>
    range(5, 10)
       5,6,7,8,9

    range(0, 10, 3)
       0, 3, 6, 9

    range(-10, -100, -30)
      -10, -40, -70
</pre>

Чтобы пройти по всем индексам какой-либо последовательности, скомбинируйте вызовы <code>range()</code> и <code>len()</code> следующим образом:

<syntaxhighlight lang="python">>>> a = ['Mary', 'had', 'a', 'little', 'lamb']
>>> for i in range(len(a)):
...     print(i, a[i])
...
0 Mary
1 had
2 a
3 little
4 lamb</syntaxhighlight>

В большинстве таких случаев удобно использовать функцию <code>enumerate()</code>.

Странные вещи начинают происходить при попытке вывода последовательности:

<syntaxhighlight lang="python">>>> print(range(10))
range(0, 10)</syntaxhighlight>

Во многих отношениях объект, возвращаемый функцией <code>range()</code>, ведёт себя как список, но фактически им не является. Это объект, который возвращает по очереди элементы желаемой последовательности, когда вы проходите по нему в цикле, но на самом деле не создаёт списка, сохраняя таким образом пространство в памяти.

Мы называем такие объекты ''итерируемыми'' (<tt>iterable</tt>), и это все объекты, которые предназначаются для функций и конструкций, ожидающих от них поочерёдного предоставления элементов до тех пор, пока источник не иссякнет. Мы видели, что оператор <code>for</code> является таким ''итератором'' <tt>iterator</tt>, примером функции, ожидающей итерарируемое значение, является <code>sum()</code>:

<syntaxhighlight lang="python">>>> sum(range(4))  # 0 + 1 + 2 + 3
6</syntaxhighlight>

Позже мы познакомимся и с другими функциями, которые возвращают и принимают ''итерируемые'' объекты в качестве параметров. Здесь стоит показать, как все же создать список из диапазона. Вот, например, решение:

<syntaxhighlight lang="python">>>> list(range(4))
[0, 1, 2, 3]</syntaxhighlight>

Мы вернемся к фукнции <code>list()</code> чуть позднее.

=== Операторы <code>break</code> и <code>continue</code>, а также условие <code>else</code> в циклах ===

Оператор <code>break</code> прерывает выполнение самого ближайшего вложенного цикла <code>for</code> или <code>while</code> (по аналогии с языком C).

Операторы циклов могут иметь ветвь <code>else</code>. Она исполняется, когда цикл выполнил перебор до конца (в случае <code>for</code>) или когда условие становится ложным (в случае <code>while</code>), но не в тех случаях, когда цикл прерывается по <code>break</code>. Это поведение иллюстрируется следующим примером, в котором производится поиск простых чисел:

<syntaxhighlight lang="python">>>> for n in range(2, 10): 
...     for x in range(2, int(n ** 0.5) + 1):
...         if n % x == 0:
...             print(n, 'равно', x, '*', n//x)
...             break
...     else:
...             print(n, '- простое число')
...
2 - простое число
3 - простое число
4 равно 2 * 2
5 - простое число
6 равно 2 * 3
7 - простое число
8 равно 2 * 4
9 равно 3 * 3</syntaxhighlight>

(да, этот код корректен. Посмотрите внимательнее: <code>else</code> является часть оператора <code>for</code>, не частью оператора <code>if</code>.)

Оператор <code>continue</code>, также заимствованный из C, продолжает выполнение цикла со следующей итерации.

<syntaxhighlight lang="python">>>> for num in range(2, 10):
...     if num % 2 == 0:
...         print("Found an even number", num)
...         continue
...     print("Found an odd number", num)
Found an even number 2
Found an odd number 3
Found an even number 4
Found an odd number 5
Found an even number 6
Found an odd number 7
Found an even number 8
Found an odd number 9</syntaxhighlight>

=== Оператор <code>pass</code> ===

Оператор <code>pass</code> не делает ничего. Он может использоваться, если синтаксически требуется присутствие оператора, но от программы не требуется действий. Например:

<pre>
    while True:
        pass # Ожидание прерывания c клавиатуры (Ctrl+C) в режиме занятости
</pre>

Этот оператор часто используется для создания минималистичных классов:

<syntaxhighlight lang="python">>>> class MyEmptyClass:
...     pass
...</syntaxhighlight>

Другой вариант: <code>pass</code> может применяться в качестве заглушки для тела функции или условия при создании нового кода, позволяя вам сохранить абстрактный взгляд на вещи. Оператор <code>pass</code> игнорируется без каких-либо сигналов:

<syntaxhighlight lang="python">>>> def initlog(*args):
...     pass  # Не забыть реализовать это!
...</syntaxhighlight>

=== Определение функций ===

Мы можем создать функцию, которая выводит последовательность Фибоначчи до произвольного предела:

<syntaxhighlight lang="python">>>> def fib(n):    # вывести числа Фибоначчи меньшие (вплоть до) n
...     """Выводит ряд Фибоначчи, ограниченный числом n."""
...     a, b = 0, 1
...     while b < n:
...         print(b, end=' ')
...         a, b = b, a+b
...
>>> # Теперь вызовем определенную нами функцию:
... fib(2000)
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597</syntaxhighlight>

Зарезервированное слово <code>def</code> предваряет ''определение'' функции. За ним должны следовать имя функции и заключённый в скобки список формальных параметров. Выражения, формирующие тело функции, начинаются со следующей строки и должны иметь отступ.

Первым выражением в теле функции может быть строковой литерал — этот литерал является строкой документации функции, или ''док-строкой'' (<tt>docstring</tt>). Существуют инструменты, которые используют ''док-строки'' для того, чтобы сгенерировать печатную или онлайн-документацию или чтобы позволить пользователю перемещаться по коду интерактивно; добавление строк документации в ваш код — это хорошая практика, постарайтесь к ней привыкнуть.

''Исполнение'' функции приводит к созданию новой таблицы символов, использующейся для хранения локальных переменных функции. Если быть более точными, все присваивания переменных в функции сохраняют значение в локальной таблице символов; при обнаружении ссылки на переменную, в первую очередь просматривается локальная таблица символов, затем локальная таблица символов для окружающих функций, затем глобальная таблица символов и, наконец, таблица встроенных имён. Таким образом, глобальным переменным и переменным окружающих функций невозможно прямо присвоить значения внутри функций (если они конечно не упомянуты в операторе <code>global</code> или, для локальных переменных окружающей функции, <code>nonlocal</code>) несмотря на то, что ссылки на них могут использоваться.

Фактические параметры (аргументы) при вызове функции помещаются в локальную таблицу символов вызванной функции; в результате аргументы передаются через ''вызов по значению'' (<tt>call by value</tt>) (где значение — это всегда ''ссылка'' (<tt>reference</tt>) на объект, а не значение его самого). Если одна функция вызывает другую или вызывает себя рекурсивно — то для этого вызова создается новая локальная таблица символов.

Определение функции связывает её имя с объектом ''функция'' в текущуей таблице символов. Тип значения, связанного с именем функции, распознается интерпретатором как функция, определённая пользователем (<tt>user-defined function</tt>). Другие имена также могут указывать на тот же самый объект и могут использоваться для доступа к функции:

<syntaxhighlight lang="python">>>> fib
<function fib at 10042ed0>
>>> f = fib
>>> f(100)
1 1 2 3 5 8 13 21 34 55 89</syntaxhighlight>

Если вы использовали в работе другие языки программирования, вы можете возразить, что <code>fib</code> — это не функция, а процедура, поскольку не возвращает никакого значения. На самом деле, даже функции без ключевого слова <code>return</code> возвращают значение, хотя и более скучное. Такое значение именуется <code>None</code> (это встроенное имя). Вывод значения <code>None</code> обычно подавляется в интерактивном режиме интерпретатора, если оно оказывается единственным значением, которое нужно вывести. Вы можете проследить за этим процессом, если действительно хотите, используя функцию <code>print()</code>:

<syntaxhighlight lang="python">>>> fib(0)
>>> print(fib(0))
None</syntaxhighlight>

Довольно легко написать функцию, которая возвращает список чисел из ряда Фибоначчи, вместо того, чтобы выводить их:

<syntaxhighlight lang="python">>>> def fib2(n): # вернуть числа Фибоначчи меньшие (вплоть до) n
...     """Возвращает список чисел ряда Фибоначчи, ограниченный n."""
...     result = []
...     a, b = 0, 1
...     while b < n:
...         result.append(b)    # см. ниже
...         a, b = b, a+b
...     return result
...
>>> f100 = fib2(100)    # вызываем
>>> f100                # выводим результат
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]</syntaxhighlight>

И на этот раз пример демонстрирует некоторые новые возможности Python:

* Оператор <code>return</code> завершает выполнение функции, возвращая некоторое значение. Оператор <code>return</code> без аргумента возвращает <code>None</code>. Достижение конца функции также возвращает <code>None</code>.

* Выражение <code>result.append(b)</code> вызывает метод <code>append</code> объекта-списка <code>result</code>. Метод — это функция, которая «принадлежит» объекту и указывается через выражение вида <code>obj.methodname</code>, где <code>obj</code> — некоторый объект (может быть выражением), а <code>methodname</code> — имя метода, присущий объекту данного типа. Различные типы определяют различные методы. Методы разных типов могут иметь одинаковые имена, не вызывая неопределённостей. (Позже в этом учебнике будет рассмотрено как определять собственные типы объектов и методы, используя классы.) Метод <code>append()</code>, показанный в примере, определён для объектов типа список. Он добавляет в конец списка новый элемент. В данном примере это действие эквивалентно выражению <code>result = result + [b]</code>, но более эффективно.

=== Подробнее об определении функций ===

Также есть возможность определять функции с переменным количеством параметров. Для этого существует три формы, которые также можно использовать совместно.

==== Значения аргументов по умолчанию ====

Наиболее полезной формой является задание значений по умолчанию для одного или более параметров. Таким образом создаётся функция, которая может быть вызвана с меньшим количеством параметров, чем в её определении: при этом неуказанные при вызове параметры примут данные в определении функции значения. Например:

<syntaxhighlight lang="python">def ask_ok(prompt, retries=4, reminder='Please try again!'):
...     while True:
...         ok = input(prompt)
...         if ok in ('y', 'ye', 'yes'):
...             return True
...         if ok in ('n', 'no', 'nop', 'nope'):
...             return False
...         retries = retries - 1
...         if retries < 0:
...             raise ValueError('invalid user response')
...         print(reminder)</syntaxhighlight>

Эта функция может быть вызвана несколькими способами:

* с передачей только обязательного аргумента:
  ``ask_ok('Do you really want to quit?')``
* с передачей одного из необязательных аргументов:
  ``ask_ok('OK to overwrite the file?', 2)``
* или с передачей всех аргументов:
  ``ask_ok('OK to overwrite the file?', 2, 'Come on, only yes or no!')``

Этот пример также знакомит вас с зарезервированным словом <code>in</code>. Посредством его можно проверить, содержит ли последовательность определённое значение или нет.

Значения по умолчанию вычисляются в месте определения функции, в ''определяющей'' области, поэтому следующий код выведет 5:

<syntaxhighlight lang="python">>>> i = 5
>>> def f(arg=i):
...     print(arg)
...
>>> i = 6
>>> f()
</syntaxhighlight>

'''Важное предупреждение:''' Значение по умолчанию вычисляется лишь единожды. Это особенно важно помнить, когда значением по умолчанию является изменяемый объект, такой как список, словарь (<tt>dictionary</tt>) или экземпляры большинства классов. Например, следующая функция накапливает переданные ей параметры:

<syntaxhighlight lang="python">>>> def f(a, L=[]):
...     L.append(a)
...     return L
...
>>> print(f(1))
>>> print(f(2))
>>> print(f(3))
</syntaxhighlight>

Если вы не хотите, чтобы значение по умолчанию разделялось последующими вызовами, вместо предыдущего варианта вы можете использовать такой код:

<syntaxhighlight lang="python">>>> def f(a, L=None):
...     if L is None:
...         L = []
...     L.append(a)
...     return L
...
>>> print(f(1))
>>> print(f(2))
>>> print(f(3))
</syntaxhighlight>

==== Именованные параметры ====

Функции также могут быть вызваны с использованием именованных параметров (<tt>keyword arguments</tt>) в форме «''имя = значение''». Например, нижеприведённая функция:

<pre>
    def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):
        print("-- This parrot wouldn't", action, end=' ')
        print("if you put", voltage, "volts through it.")
        print("-- Lovely plumage, the", type)
        print("-- It's", state, "!")
</pre>

принимает один обязательный аргумент (``voltage``) и три опциональных аргумента (``state``, ``action``, and ``type``). Эта функция могла бы быть вызвана любым из следующих способов:

<pre>
   parrot(1000)                                          # 1 поциционный аргумент
   parrot(voltage=1000)                                  # 1 именованный аргумент
   parrot(voltage=1000000, action='VOOOOOM')             # 2 именованных аргумента
   parrot(action='VOOOOOM', voltage=1000000)             # 2 именованных аргумента
   parrot('a million', 'bereft of life', 'jump')         # 3 позционных аргумента
   parrot('a thousand', state='pushing up the daisies')  # 1 позиционный, 1 именованный
</pre>

а эти случаи оказались бы неверными:

<pre>
    parrot()                     # пропущен требуемый аргумент
    parrot(voltage=5.0, 'dead')  # позиционный параметр вслед за именованным
    parrot(110, voltage=220)     # повторное значение параметра
    parrot(actor='John Cleese')  # неизвестное имя параметра
</pre>

При вызове функции именованные аргументы должы следовать за позиционными. Все переданные в вызове именованные аргументы должы совпадать по имени с одним из аргументов, определенных в функции (например, ''actor'' не является правильным аргументом для функции ''parrot''), их порядок не важен. Это также относится к обязательным аргументам (т.е. ''parrot(voltage=1000)'' является корректным вызовом функции). Ни один из аргументов не может получать значение более чем один раз. Вот пример, завершающийся неудачей по причине описанного ограничения:

<syntaxhighlight lang="python">>>> def function(a):
...     pass
...
>>> function(0, a=0)
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
TypeError: function() got multiple values for keyword argument 'a'</syntaxhighlight>

Если в определении функции присутствует завершающий параметр в виде <code>\*\*name</code>, он получит в качестве значения словарь (подробнее в разделе Типы данных - словари), содержащий все именованные параметры и их значения, исключая те, которые соответствуют формальным параметрам. Можно совместить это с поддержкой формального параметра в формате <code>\*name</code> (описывается в следующем подразделе), который получает кортеж (<tt>tuple</tt>), содержащий все позиционные параметры, следующие за списком формальных параметров. (параметр в формате <code>\*name</code> должен быть в списке параметров перед параметром в формате <code>\*\*name</code>.) Например, если мы определим такую функцию:

<pre>
    def cheeseshop(kind, *arguments, **keywords):
        print("-- Do you have any", kind, "?")
        print("-- I'm sorry, we're all out of", kind)
        for arg in arguments: 
            print(arg)
        print("-" * 40)
        for kw in keywords:
           print(kw, ":", keywords[kw])
</pre>

то её можно будет вызвать так:

<pre>
    cheeseshop('Limburger', "It's very runny, sir.",
               "It's really very, VERY runny, sir.",
               shopkeeper="Michael Palin",
               client="John Cleese",
               sketch="Cheese Shop Sketch")
</pre>

и она, конечно же, выведет>:

<pre>
    -- Do you have any Limburger ?
    -- I'm sorry, we're all out of Limburger
    It's very runny, sir.
    It's really very, VERY runny, sir.
    ----------------------------------------
    client : John Cleese
    shopkeeper : Michael Palin
    sketch : Cheese Shop Sketch
</pre>

Обратите внимание, что порядок, в котором были выведены именованные аргументы, гарантированно совпадает с порядком, в котором они следовали при вызове функции.

==== Списки параметров произвольной длины ====

Наконец, наиболее редко используется возможность указания того, что функция может быть вызвана с произвольным числом аргументов. При этом сами параметры будут обёрнуты в кортеж (см. раздел Кортежи). Переменное количество параметров могут предварять ноль или более обычных параметров.

<pre>
    def write_multiple_items(file, separator, *args):
        file.write(separator.join(args))
</pre>

Обычно параметры неизвестного заранее количества (<tt>variadic</tt>) указываются последними в списке формальных параметров, поскольку включают в себя все остальные переданные в функцию параметры. Все формальные параметры, которые следуют за параметром <code>\*args</code>, должны быть только именованными, то есть, они могут быть заданы только по имени (в отличие от позиционных параметров).

<syntaxhighlight lang="python">>>> def concat(*args, sep="/"):
...    return sep.join(args)
...
>>> concat("earth", "mars", "venus")
'earth/mars/venus'
>>> concat("earth", "mars", "venus", sep=".")
'earth.mars.venus'</syntaxhighlight>

==== Распаковка списков параметров ====

Обратная ситуация возникает когда параметры уже содержатся в списке или в кортеже, но должны быть распакованы для вызова функции, требующей отдельных позиционных параметров. Например, встроенная функция <code>range()</code> ожидает отдельные параметры ''start'' и ''stop'' соответственно. Если они не доступны раздельно, для распаковки аргументов из списка или кортежа в вызове функции используйте оператор ''\*'':

<syntaxhighlight lang="python">>>> list(range(3, 6))             # обычный вызов с отдельными параметрами
[3, 4, 5]
>>> args = [3, 6]
>>> list(range(*args))            # вызов с распакованными из списка параметрами
[3, 4, 5]</syntaxhighlight>

Схожим способом, словари могут поставлять именованные параметры с помощью оператора ''\*\*'':

<syntaxhighlight lang="python">>>> def parrot(voltage, state='a stiff', action='voom'):
...     print("-- This parrot wouldn't", action, end=' ')
...     print("if you put", voltage, "volts through it.", end=' ')
...     print("E's", state, "!")
...
>>> d = {"voltage": "four million", "state": "bleedin' demised", "action": "VOOM"}
>>> parrot(**d)
-- This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised !</syntaxhighlight>

==== lambda Выражения ====

Используя зарезервированное слово <code>lambda</code>, вы можете создать небольшую безымянную функцию. Например, функцию, которая возвращает сумму двух своих аргументов, можно записать так: <code>lambda a, b: a+b</code>. Формы <code>lambda</code> могут быть использованы в любом месте, где требуется объект функции. При этом они синтаксически ограничены одним выражением. Семантически, они лишь «синтаксический сахар» для обычного определения функции. Как и определения вложенных функций, <code>lambda</code>-формы могут ссылаться на переменные из содержащей их области видимости:

<syntaxhighlight lang="python">>>> def make_incrementor(n):
...     return lambda x: x + n
...
>>> f = make_incrementor(42)
>>> f(0)
42
>>> f(1)
43</syntaxhighlight>

Пример. выше использует lambda выражение для возврата значения из функции. Другое применение - передача небольшой функции в качестве аргумента:

<syntaxhighlight lang="python">>>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]
>>> pairs.sort(key=lambda pair: pair[1])
>>> pairs
[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]</syntaxhighlight>

==== Строки документации ====

Перечислим некоторые существующие соглашения по содержимому строк документации и их форматированию.

Первая строка всегда должна быть сжатой, лаконичной сводкой о назначении объекта. Для краткости, в ней не обязательно присутствие имени типа или объекта, поскольку они доступны другими способами (исключая случай, когда имя функции оказывается глаголом, описывающим суть операции). Эта строка должна начинаться с прописной буквы и оканчиваться точкой.

Если строке документации (литералу, объекту строки) требуется больше строк (физических), вторая строка должна быть пустой, визуально отделяя сводку от остального описания. Следующие строки могут быть одним или более абзацем, описывающим соглашения по вызову объекта, сторонние эффекты, и т. д.

Парсер Python не обрабатывает отступы в много-строковых литералах, поэтому инструментам, которые работают над документацией, предлагается, по желанию, делать это самим. Производится это по следующему соглашению. Первая непустая строка после первой строки литерала определяет величину отступа всего литерала документации. (Мы не можем использовать первую строку, поскольку она обычно выравнивается по открывающим кавычкам и её отступ в литерале не явен). Пробельный «эквивалент» этого отступа затем отрезается от начала всех строк литерала. Строк с меньшим отступом не должно обнаруживаться, но если они встретились, весь их начальный отступ должен быть обрезан. Эквивалентность пробельных замен может быть протестирована развертыванием табуляции (обычно, к 8 пробелам).

Вот пример многострочной документации (''док-строки''):

<syntaxhighlight lang="python">>>> def my_function():
...     """Не делаем ничего, но документируем.
...
...     Нет, правда, эта функция ничего не делает.
...     """
...     pass
...
>>> print(my_function.__doc__)
Не делаем ничего, но документируем.

    Нет, правда, эта функция ничего не делает.</syntaxhighlight>

=== Аннотации функци ===

Аннотации функций - это полностью опциональная мета информакци о типах, используемых в определенной пользователем функции (см. PEP-3107).

Аннотации функций сохраняются в атрибуте ''__annotations__'' функции в виде словаря и не оказывают никакого влияния на любую другую часть функции. Аннотации параметров отделяются от их имен двоеточием, за которым следует выражение, определяющее значение аннотации. Аннтотация возвращаемого значения  определяется с помощью литерала ''->'' и следующего за ним выражения, аннотация возвращаемого значения расположена между списком параметров и двоеточием в конце оператора <code>def</code>. В следующем примере позиционный аргумент, именованный аргумент и возвращаемое значение аннотированы:  

<syntaxhighlight lang="python">>>> def f(ham: str, eggs: str = 'eggs') -> str:
...     print("Annotations:", f.__annotations__)
...     print("Arguments:", ham, eggs)
...     return ham + ' and ' + eggs
...
>>> f('spam')
Annotations: {'ham': <class 'str'>, 'return': <class 'str'>, 'eggs': <class 'str'>}
Arguments: spam eggs
'spam and eggs'</syntaxhighlight>

=== Интермеццо: Стиль написания кода ===

Теперь, когда вам предстоит писать более объёмные и сложные блоки кода на Python, настало время поговорить о ''стиле написания кода'' (<tt>coding style</tt>). Код на большинстве языков программирования может быть записан (или, точнее говоря, ''отформатирован'' (<tt>formatted</tt>)) различными способами; некоторые из них более читабельны, некоторые — нет. Стремление к написанию лёгкого для прочтения другими кода всегда считалось хорошим тоном, и выбор правильного стиля для кода крайне ему способствует.

В случае языка Python, в качестве руководства по стилю было создано предложение PEP-8, которого придерживаются создатели большинства проектов. В нём учреждается чрезвычайно читабельный и приятный для глаза стиль написания кода. В некоторый момент с ним должен ознакомиться каждый разработчик на Python. Приведём здесь избранные, наиболее важные, пункты:

* Используйте отступ в 4 пробела, не используйте табуляцию
: 4 пробела легко опознаются и в случае небольших отступов (хватает места для глубоких вложений) и в случае больших отступов (приятнее читается). Табуляция вносит путаницу и лучше от неё воздержаться.
* Разделяйте строки так, чтобы их длина не превышала 79-и символов
: Это поможет пользователям с небольшими экранами, а пользователям с большими экранами позволит уложить несколько файлов с исходным кодом рядом.
* Используйте пустые строки для отделения функций, классов, и крупных блоков внутри функций.
* При возможности располагайте комментарий на отдельной строке.
* Используйте строки документации (''док-строки'')
* Применяйте пробелы вокруг символов операций и после запятых, но не добавляйте их в конструкции со скобками: <code>a = f(1, 2) + g(3, 4)</code>
* Называйте ваши классы и функции единообразно; соглашение следующее: используйте <code>UpperCamelCase</code> для именования классов и <code>нижний\_регистр\_с\_подчёркиваниями</code> для функций и методов. Всегда называйте первый аргумент метода класса ''self''.
* Не используйте в вашем коде изощрённых кодировок, если он рассчитан на использование в интернациональной среде. Кодировка по умолчанию для Python - UTF-8 или стандартный набор ASCII всегда работает на ура.
* Аналогично, не используйте не-ASCII символы в идентификаторах, если есть хоть малейшая вероятность того, что ваш кд будут читать или поддерживать люди, говорящие на другом языке.
