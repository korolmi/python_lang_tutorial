
== Больше средств для управления потоком команд<ref>''(Прим. перев.)'' More Control Flow Tools; [[w:en:Control Flow|Control Flow]] — поток команд, процесс управления, алгоритм; подразделы в оригинале используют множественное число: "Операторы (выражения, инструкции) <code>if</code>, «Операторы (выражения, инструкции) <code>for</code>», и. т. п.</ref> ==

Помимо описанного выше оператора <code>while</code>, в Python доступны привычные операторы управления потоком из других языков, но с некоторыми особенностями.

=== Оператор <code>if</code> ===

Возможно, наиболее широко известный тип оператора — оператор <code>if</code> (если). Пример:

<syntaxhighlight lang="python">>>> x = int(input("Введите, пожалуйста, целое число: "))
Введите, пожалуйста, целое число: 42
>>> if x < 0:
...      x = 0
...      print('Отрицательное значение, изменено на ноль')
... elif x == 0:
...      print('Ноль')
... elif x == 1:
...      print('Один')
... else:
...      print('Больше')
...</syntaxhighlight>

Блока <code>elif</code> может не быть вообще, он может быть один или их может быть несколько, а блок <code>else</code> (иначе) необязателен. Ключевое слово <tt>elif</tt> — краткая запись <tt>else if</tt> (иначе если) — позволяет избавиться от чрезмерного количества отступов. Оператор <code>if</code> <tt>...</tt> <code>elif</code> <tt>...</tt> <code>elif</code> <tt>...</tt> — аналог оператора выбора <code>switch</code> или <code>case</code>, которые можно встретить в других языках программирования.

=== Оператор <code>for</code> ===

Оператор <code>for</code> в Python немного отличается от того, какой вы, возможно, использовали в C или Pascal. Вместо неизменного прохождения по арифметической прогрессии из чисел (как в Pascal) или предоставления пользователю возможности указать шаг итерации и условие остановки (как в С), оператор <code>for</code> в Python проходит по всем элементам любой последовательности (списка или строки) в том порядке, в котором они в ней располагаются. Например (игра слов не подразумевалась):<ref>''(Прим. перев.)'' Defenestrate{{ref-en}} — выкидывать кого-либо из окна с целью покалечить. Другие слова — «кошка» и «окно».</ref>

<syntaxhighlight lang="python">>>> # Измерим несколько строк:
... a = ['cat', 'window', 'defenestrate']
>>> for x in a:
...     print(x, len(x))
...
cat 3
window 6
defenestrate 12</syntaxhighlight>

Изменять содержимое последовательности, по которой проходит цикл, небезопасно (это в принципе-то возможно только для изменяемых типов, таких как списки). Если необходимо модифицировать список, использующийся для организации цикла, (например, для того чтобы продублировать отдельные элементы) нужно передать циклу его копию. Нотация срезов делает это практически безболезненным:

<syntaxhighlight lang="python">>>> for x in a[:]:  # создать срез-копию всего списка
...    if len(x) > 6: a.insert(0, x)
...
>>> a
['defenestrate', 'cat', 'window', 'defenestrate']</syntaxhighlight>

=== Функция <code>range()</code> ===

Если вам нужно перебрать последовательность чисел, встроенная функция <code>range()</code> придёт на помощь. Она генерирует арифметические прогрессии:

<syntaxhighlight lang="python">>>> for i in range(5):
...    print(i)
...
0
1
2
3
4</syntaxhighlight>

Указанный конец интервала никогда не включается в сгенерированный список; вызов <code>range(10)</code> генерирует десять значений, которые являются подходящими индексами для элементов последовательности длины 10. Можно указать другое начало интервала и другую, даже отрицательную, величину шага.

<syntaxhighlight lang="python">range(5, 10)
   от 5 до 9

range(0, 10, 3)
   0, 3, 6, 9

range(-10, -100, -30)
   -10, -40, -70</syntaxhighlight>

Чтобы пройти по всем индексам какой-либо последовательности, скомбинируйте вызовы <code>range()</code> и <code>len()</code> следующим образом:

<syntaxhighlight lang="python">>>> a = ['Mary', 'had', 'a', 'little', 'lamb']
>>> for i in range(len(a)):
...     print(i, a[i])
...
0 Mary
1 had
2 a
3 little
4 lamb</syntaxhighlight>

В большинстве таких случаев удобно использовать функцию <code>enumerate()</code>, обратитесь к [[Учебник Python 3.1#Организация циклов|Организация циклов]].

Странные вещи начинают происходить при попытке вывода последовательности:

<syntaxhighlight lang="python">>>> print(range(10))
range(0, 10)</syntaxhighlight>

Во многих случаях объект, возвращаемый функцией <code>range()</code>, ведёт себя как список, но фактически им не является. Этот объект возвращает по очереди элементы желаемой последовательности, когда вы проходите по нему в цикле, но на самом деле не создаёт списка, сохраняя таким образом пространство в памяти.

Мы называем такие объекты ''итерируемыми'' (<tt>iterable</tt>), и это все объекты, которые предназначаются для функций и конструкций, ожидающих от них поочерёдного предоставления элементов до тех пор, пока источник не иссякнет. Мы видели, что оператор <code>for</code> является таким ''итератором'' <tt>iterator</tt>. Функция <code>list()</code> тоже из их числа — она создаёт списки из ''итерируемых'' объектов:

<syntaxhighlight lang="python">>>> list(range(5))
[0, 1, 2, 3, 4]</syntaxhighlight>

Позже мы познакомимся и с другими функциями, которые возвращают и принимают ''итерируемые'' объекты в качестве параметров.

=== Операторы <code>break</code> и <code>continue</code>, а также условие <code>else</code> в циклах ===

Оператор <code>break</code> прерывает выполнение самого ближайшего вложенного цикла <code>for</code> или <code>while</code> (по аналогии с языком C).

Оператор <code>continue</code>, также заимствованный из C, продолжает выполнение цикла со следующей итерации.

Операторы циклов могут иметь ветвь <code>else</code>. Она исполняется, когда цикл выполнил перебор до конца (в случае <code>for</code>) или когда условие становится ложным (в случае <code>while</code>), но не в тех случаях, когда цикл прерывается по <code>break</code>. Это поведение иллюстрируется следующим примером, в котором производится поиск простых чисел:

<syntaxhighlight lang="python">>>> for n in range(2, 10): 
...     for x in range(2, int(n ** 0.5) + 1):
...         if n % x == 0:
...             print(n, 'равно', x, '*', n//x)
...             break
...     else:
...             print(n, '- простое число')
...
2 - простое число
3 - простое число
4 равно 2 * 2
5 - простое число
6 равно 2 * 3
7 - простое число
8 равно 2 * 4
9 равно 3 * 3</syntaxhighlight>

=== Оператор <code>pass</code> ===

Оператор <code>pass</code> не делает ничего. Он может использоваться когда синтаксически требуется присутствие оператора, но от программы не требуется действий. Например:

<syntaxhighlight lang="python">>>> while True:
...       pass # Ожидание прерывания c клавиатуры (Ctrl+C) в режиме занятости
...</syntaxhighlight>

Этот оператор часто используется для создания минималистичных классов, к примеру ''исключений'' (<tt>exceptions</tt>), или для игнорирования нежелательных исключений:

<syntaxhighlight lang="python">>>> class ParserError(Exception):
...     pass
...
>>> try:
...     import audioop
... except ImportError:
...     pass
...</syntaxhighlight>

Другой вариант: <code>pass</code> может применяться в качестве заглушки для тела функции или условия при создании нового кода, позволяя вам сохранить абстрактный взгляд на вещи. С другой стороны, оператор <code>pass</code> игнорируется без каких-либо сигналов и лучшим выбором было бы породить исключение <code>NotImplementedError</code>:

<syntaxhighlight lang="python">>>> def initlog(*args):
...     raise NotImplementedError   # Открыть файл для логгинга, если он ещё не открыт
...     if not logfp:
...         raise NotImplementedError  # Настроить заглушку для логгинга
...     raise NotImplementedError('Обработчик инициализации лога вызовов')
...</syntaxhighlight>

Если бы здесь использовались операторы <code>pass</code>, а позже вы бы запускали тесты, они могли бы упасть без указания причины. Использование <code>NotImplementedError</code> принуждает этот код породить исключение, сообщая вам конкретное место, где присутствует незавершённый код. Обратите внимание на два способа порождения исключений. Первый способ, без сообщения, но сопровождаемый комментарием, позволяет вам оставить комментарий когда вы будете подменять выброс исключения рабочим кодом, который, в свою очередь, в идеале, будет хорошим описанием блока кода, для которого исключение предназначалось заглушкой. Однако, передача сообщения вместе с исключением, как в третьем примере, обуславливает более насыщенный информацией вывод при отслеживании ошибки.

=== Определение функций ===

Мы можем создать функцию, которая выводит последовательность Фибоначчи до некоторого предела:

<syntaxhighlight lang="python">>>> def fib(n):    # вывести числа Фибоначчи меньшие (вплоть до) n
...     """Выводит ряд Фибоначчи, ограниченный числом n."""
...     a, b = 0, 1
...     while b < n:
...         print(b, end=' ')
...         a, b = b, a+b
...
>>> # Теперь вызовем определенную нами функцию:
... fib(2000)
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597</syntaxhighlight>

Зарезервированное слово <code>def</code> предваряет ''определение'' функции. За ним должны следовать имя функции и заключённый в скобки список формальных параметров. Выражения, формирующие тело функции, начинаются со следующей строки и должны иметь отступ.

Первым выражением в теле функции может быть строковой литерал — этот литерал является строкой документации функции, или ''док-строкой'' (<tt>docstring</tt>). (Больше информации о ''док-строках'' вы найдёте в разделе [[Учебник Python 3.1#Строки документации|Строки документации]]) Существуют инструменты, которые используют ''док-строки'' для того, чтобы сгенерировать печатную или онлайн-документацию или чтобы позволить пользователю перемещаться по коду интерактивно; добавление строк документации в ваш код — это хорошая практика, постарайтесь к ней привыкнуть.

''Исполнение'' функции приводит к созданию новой таблицы символов<ref>''(Прим. перев.)'' Здесь слово «символ» используется не в привычном значении — под ''символом'' подразумевается нечто лингвистическое, описывающее какую-либо сущность (близко к значению ''символизировать''), в данном случае: имя переменной — саму переменную.</ref>, использующейся для хранения локальных переменных функции. Если быть более точными, все присваивания переменных в функции сохраняют значение в локальной таблице символов; при обнаружении ссылки на переменную, в первую очередь просматривается локальная таблица символов, затем локальная таблица символов для окружающих функций, затем глобальная таблица символов и, наконец, таблица встроенных имён. Таким образом, глобальным переменным невозможно прямо присвоить значения внутри функций (если они конечно не упомянуты в операторе <code>global</code>) несмотря на то, что ссылки на них могут использоваться.

Фактические параметры при вызове функции помещаются в локальную таблицу символов вызванной функции; в результате аргументы передаются через ''вызов по значению'' (<tt>call by value</tt>) (где значение — это всегда ''ссылка'' (<tt>reference</tt>) на объект, а не значение его самого)<ref>На самом деле, лучшим определением был бы ''вызов по ссылке на объект'' (<tt>call by object reference</tt>), так как при передаче изменяемого объекта, вызывающему будут видны все изменения, которые производит над объектом вызываемый (вставка элементов в список)</ref>. Если одна функция вызывает другую — то для этого вызова создается новая локальная таблица символов.

При определении функции её имя также помещается в текущую таблицу символов. Тип значения, связанного с именем функции, распознается интерпретатором как функция, определённая пользователем (<tt>user-defined function</tt>). Само значение может быть присвоено другому имени, которое затем может также использоваться в качестве функции. Эта система работает в виде основного механизма переименования:

<syntaxhighlight lang="python">>>> fib
<function fib at 10042ed0>
>>> f = fib
>>> f(100)
1 1 2 3 5 8 13 21 34 55 89</syntaxhighlight>

Если вы использовали в работе другие языки программирования, вы можете возразить, что <code>fib</code> — это не функция, а процедура, поскольку не возвращает никакого значения. На самом деле, даже функции без ключевого слова <code>return</code> возвращают значение, хотя и более скучное. Такое значение именуется <code>None</code> (это встроенное имя). Вывод значения <code>None</code> обычно подавляется в интерактивном режиме интерпретатора, если оно оказывается единственным значением, которое нужно вывести. Вы можете проследить за этим процессом, если действительно хотите, используя функцию <code>print()</code>:

<syntaxhighlight lang="python">>>> fib(0)
>>> print(fib(0))
None</syntaxhighlight>

Довольно легко написать функцию, которая возвращает список чисел из ряда Фибоначчи, вместо того, чтобы выводить их:

<syntaxhighlight lang="python">>>> def fib2(n): # вернуть числа Фибоначчи меньшие (вплоть до) n
...     """Возвращает список чисел ряда Фибоначчи, ограниченный n."""
...     result = []
...     a, b = 0, 1
...     while b < n:
...         result.append(b)    # см. ниже
...         a, b = b, a+b
...     return result
...
>>> f100 = fib2(100)    # вызываем
>>> f100                # выводим результат
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]</syntaxhighlight>

И на этот раз пример демонстрирует некоторые новые возможности Python:

* Оператор <code>return</code> завершает выполнение функции, возвращая некоторое значение. Оператор <code>return</code> без аргумента возвращает <code>None</code>. Достижение конца функции также возвращает <code>None</code>.

* Выражение <code>result.append(b)</code> вызывает метод <code>append</code> объекта-списка <code>result</code>. Метод — это функция, которая «принадлежит» объекту и указывается через выражение вида <code>obj.methodname</code>, где <code>obj</code> — некоторый объект (может быть выражением), а <code>methodname</code> — имя метода, присущий объекту данного типа. Различные типы определяют различные методы. Методы разных типов могут иметь одинаковые имена, не вызывая неопределённостей. (Позже в этом учебнике будет рассмотрено как определять собственные типы объектов и методы, используя классы.) Метод <code>append()</code>, показанный в примере, определён для объектов типа список. Он добавляет в конец списка новый элемент. В данном примере это действие эквивалентно выражению <code>result = result + [b]</code>, но более эффективно.

=== Подробнее об определении функций ===

Также есть возможность определять функции с переменным количеством параметров. Для этого существует три формы, которые также можно использовать совместно.

==== Значения аргументов по умолчанию ====

Наиболее полезной формой является задание значений по умолчанию для одного или более параметров. Таким образом создаётся функция, которая может быть вызвана с меньшим количеством параметров, чем в её определении: при этом неуказанные при вызове параметры примут данные в определении функции значения. Например<ref>''(Прим. перев.):''
<br /><br />
<code style="background-color: inherit !important;">'''опред''' спросить_подтверждения(вопрос, попытки=4, протест='Да или нет, пожалуйста!'):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;'''пока''' ''Истина'':<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ответ = ''ввод''(вопрос)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'''если''' ответ '''среди''' ('д', 'да', 'ага'): '''вернуть''' ''Истина''<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'''если''' ответ '''среди''' ('н', 'не', 'нет', 'не-а'): '''вернуть''' ''Ложь''<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;попытки = попытки - 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'''если''' попытки < 0: '''породить''' ОшибкаВВ('пользователь-отказник')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'''вывести'''(протест)</code><br /><br />
(''Refusenik''{{ref-en}} — [[w:ru:Отказник|Отказник]]). Ниже: «…<code>спросить_подтверждения('Вы действительно хотите выйти?')</code> или так: <code>спросить_подтверждения('Согласны ли вы перезаписать файл?', 2)</code>…»</ref>:

<syntaxhighlight lang="python">def ask_ok(prompt, retries=4, complaint='Yes or no, please!'):
    while True:
        ok = input(prompt)
        if ok in ('y', 'yeah', 'yes', 'yep'): return True
        if ok in ('n', 'no', 'nop', 'nope'): return False
        retries = retries - 1
        if retries < 0:
            raise IOError('refusenik user')
        print(complaint)</syntaxhighlight>

Эта функция может быть вызвана, например, так: <code>ask_ok('Do you really want to quit?')</code> или так: <code>ask_ok('OK to overwrite the file?', 2)</code>.

Этот пример также знакомит вас с зарезервированным словом <code>in</code>. Посредством его можно проверить, содержит ли последовательность определённое значение или нет.

Значения по умолчанию вычисляются в месте определения функции, в ''определяющей'' области, поэтому код

<syntaxhighlight lang="python">i = 5

def f(arg=i):
    print(arg)

i = 6
f()</syntaxhighlight>

выведет 5.

'''Важное предупреждение:''' Значение по умолчанию вычисляется лишь единожды. Это особенно важно помнить, когда значением по умолчанию является изменяемый объект, такой как список, словарь (<tt>dictionary</tt>) или экземпляры большинства классов. Например, следующая функция накапливает переданные ей параметры:

<syntaxhighlight lang="python">def f(a, L=[]):
    L.append(a)
    return L

print(f(1))
print(f(2))
print(f(3))</syntaxhighlight>

Она выведет

<syntaxhighlight lang="python">[1]
[1, 2]
[1, 2, 3]</syntaxhighlight>

Если вы не хотите, чтобы значение по умолчанию распределялось между последовательными вызовами, вместо предыдущего варианта вы можете использовать такую идиому:

<syntaxhighlight lang="python">def f(a, L=None):
    if L is None:
        L = []
    L.append(a)
    return L</syntaxhighlight>

==== Именованные параметры<ref>''(Прим. перев.)'' В оригинале — Keyword Arguments — параметры по ключевым словам, ключевые параметры (далее используется слово ''keywords'' для набора имён параметров непостоянного количества. ''Ключевые'' — возможно, корректнее, но как мне показалось — менее понятно ([http://www.infocity.kiev.ua/prog/python/content/sempit_14.phtml альтернативный перевод]))</ref> ====

Функции также могут быть вызваны с использованием именованных параметров (<tt>keyword arguments</tt>) в форме «''имя = значение''». Например, нижеприведённая функция<ref>''(Прим. перев.):''
<br /><br />
<code style="background-color: inherit !important;">'''опред''' попугай(вольтаж, состояние='труп', действие='ввум', тип='Норвежский Голубой'):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;'''вывести'''("-- Этот попугай не сделает ", действие, завершить=' ')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;'''вывести'''("если вы пропустите через него ", вольтаж, " вольт.")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;'''вывести'''("-- Великолепное оперенье, ", тип)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;'''вывести'''("-- Он", состояние, "!")</code><br /><br />
(''Из [http://www.ibras.dk/montypython/episode08.htm#6 скетча Монти Пайтона]'')</ref>:

<syntaxhighlight lang="python">def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):
    print("-- This parrot wouldn't", action, end=' ')
    print("if you put", voltage, "volts through it.")
    print("-- Lovely plumage, the", type)
    print("-- It's", state, "!")</syntaxhighlight>

могла бы быть вызвана любым из следующих способов<ref>''(Прим. перев.):''
<br /><br />
<code style="background-color: inherit !important;">попугай(действие='ВВУУУУМ', вольтаж=1000000)<br/>
попугай('тысячу', состояние='слёг в могилу')<br/>
попугай('миллион', 'лишённый жизни', 'прыжок')</code><br /><br /></ref>:

<syntaxhighlight lang="python">parrot(1000)
parrot(action='VOOOOOM', voltage=1000000)
parrot('a thousand', state='pushing up the daisies')
parrot('a million', 'bereft of life', 'jump')</syntaxhighlight>

а эти случаи оказались бы неверными<ref>''(Прим. перев.):''
<br /><br />
<code style="background-color: inherit !important;">попугай()<br/>
попугай(вольтаж=5.0, 'мёртв')<br/>
попугай(исполнитель='Джон Клиз')</code><br /><br /></ref>:

<syntaxhighlight lang="python">parrot()                     # пропущен требуемый аргумент
parrot(voltage=5.0, 'dead')  # позиционный параметр вслед за именованным
parrot(110, voltage=220)     # повторное значение параметра
parrot(actor='John Cleese')  # неизвестное имя параметра</syntaxhighlight>

В общем случае, список параметров должен содержать любое количество позиционных (<tt>positional</tt>) параметров, за которыми может следовать любое количество именованных, и при этом имена аргументов выбираются из формальных параметров. Неважно, имеет формальный параметр значение по умолчанию или нет. Ни один из аргументов не может получать значение более чем один раз — имена формальных параметров, совпадающие с именами позиционных параметров, не могут использоваться в качестве именующих в одном и том же вызове<ref>''(Прим. перев.)'' В главе о функциях автор отталкивается не от привычного по другим учебникам первоначального полного описания определения функций, а уже потом — описания их вызова, а объединяет обе темы вместе (как минимум в случае с непостоянным списком аргументов это возможно непривычно, но оправдано), отдавая приоритет описанию вызова. Учебник рассчитан на тех, кто уже программирует на каком-либо языке программирования и потенциально не должен смутить читателя.</ref>. Вот пример, завершающийся неудачей по причине описанного ограничения:

<syntaxhighlight lang="python">>>> def function(a):
...     pass
...
>>> function(0, a=0)
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
TypeError: function() got multiple values for keyword argument 'a'</syntaxhighlight>

Если в определении функции присутствует завершающий параметр в виде ''**имя'', он получит в качестве значения словарь (подробнее в разделе [[Справочник по библиотеке Python 3.1#Типы-отображения|Справочника — Типы-отображения — словари]]), содержащий все именованные параметры и их значения, исключая те, которые соответствуют формальным параметрам. Можно совместить эту особенность с поддержкой формального параметра в формате ''*имя'' (описывается в следующем подразделе), который получает кортеж (<tt>tuple</tt>), содержащий все позиционные параметры, следующие за списком формальных параметров. (параметр в формате ''*имя'' должен описываться перед параметром в формате ''**имя''.) Например, если мы определим такую функцию<ref>''(Прим. перев.):''
<br /><br />
<code style="background-color: inherit !important;">'''опред''' лавка_сыров(сорт, *аргументы, **именованные):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;'''вывести'''("-- Есть ли у вас ", сорт, '?')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;'''вывести'''("-- Простите, весь ", сорт, " у нас закончился.")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;'''для''' аргумент '''из''' аргументы: '''вывести'''(аргумент)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;'''вывести'''('-' * 40)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;имена = '''сортированные'''(именованные.''ключи''())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;'''для''' имя '''из''' имена: '''вывести'''(имя , ":", именованные[имя])</code><br /><br />
(''Из [http://www.ibras.dk/montypython/episode33.htm#7 скетча Монти Пайтона]'')</ref>:

<syntaxhighlight lang="python">def cheeseshop(kind, *arguments, **keywords):
    print("-- Do you have any", kind, "?")
    print("-- I'm sorry, we're all out of", kind)
    for arg in arguments: print(arg)
    print("-" * 40)
    keys = sorted(keywords.keys())
    for kw in keys: print(kw, ":", keywords[kw])</syntaxhighlight>

то её можно будет вызвать так<ref>''(Прим. перев.):''
<br /><br />
<code style="background-color: inherit !important;">лавка_сыров("Лимбургер", "Это очень расстраивает, сэр.",<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Это действительно очень, ОЧЕНЬ расстраивает, сэр.",<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;торговец="Майкл Палин",<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;клиент="Джон Клиз",<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;скетч="Скетч о сырной лавке")</code></ref>:

<syntaxhighlight lang="python">cheeseshop('Limburger', "It's very runny, sir.",
           "It's really very, VERY runny, sir.",
           client="John Cleese",
           shopkeeper="Michael Palin",
           sketch="Cheese Shop Sketch")</syntaxhighlight>

и она, конечно же, выведет<ref>''(Прим. перев.):''
<br/><br/>
<code style="background-color: inherit !important;">-- Есть ли у вас Лимбургер ?<br/>
-- Простите, весь Лимбургер у нас закончился.<br/>
Это очень расстраивает, сэр.<br/>
Это действительно очень, ОЧЕНЬ расстраивает, сэр.<br/>
<nowiki>----------------------------------------</nowiki><br/>
клиент: Джон Клиз<br/>
торговец : Майкл Палин<br/>
скетч : Скетч о сырной лавке</code><br /><br /></ref>:

<code>-- Do you have any Limburger ?<br/>
-- I'm sorry, we're all out of Limburger<br/>
It's very runny, sir.<br/>
It's really very, VERY runny, sir.<br/>
<nowiki>----------------------------------------</nowiki><br/>
client : John Cleese<br/>
shopkeeper : Michael Palin<br/>
sketch : Cheese Shop Sketch</code>

Обратите внимание, что список имён (ключей) именованных параметров (<code>keys</code>) создается посредством сортировки содержимого списка ключей <code>keys()</code> словаря <code>keywords</code>; если бы этого не было сделано, порядок вывода параметров был бы произволен.

==== Списки параметров произвольной длины ====

Наконец, наиболее редко используется возможность указания того, что функция может быть вызвана с произвольным числом аргументов. При этом сами параметры будут обёрнуты в кортеж (см. раздел [[Учебник Python 3.1#Кортежи|Кортежи]]). Переменное количество параметров могут предварять ноль или более обычных.

<syntaxhighlight lang="python">def write_multiple_items(file, separator, *args):
    file.write(separator.join(args))</syntaxhighlight>

Обычно параметры неизвестного заранее количества (<tt>variadic</tt>) указываются последними в списке формальных параметров, поскольку включают в себя все остальные переданные в функцию параметры. Все формальные параметры, которые следуют за параметром <code>*args</code>, должны быть только именованными, то есть, они могут быть заданы только по имени (в отличие от позиционных параметров).

<syntaxhighlight lang="python">>>> def concat(*args, sep="/"):
...    return sep.join(args)
...
>>> concat("earth", "mars", "venus")
'earth/mars/venus'
>>> concat("earth", "mars", "venus", sep=".")
'earth.mars.venus'</syntaxhighlight>

==== Распаковка списков параметров ====

Обратная ситуация возникает когда параметры уже содержатся в списке или в кортеже, но должны быть распакованы для вызова функции, требующей отдельных позиционных параметров. Например, встроенная функция <code>range()</code> ожидает отдельные параметры ''start'' и ''stop'' соответственно. Если они не доступны раздельно, для распаковки аргументов из списка или кортежа в вызове функции используйте *-синтаксис:

<syntaxhighlight lang="python">>>> list(range(3, 6))             # обычный вызов с отдельными параметрами
[3, 4, 5]
>>> args = [3, 6]
>>> list(range(*args))            # вызов с распакованными из списка параметрами
[3, 4, 5]</syntaxhighlight>

Схожим способом, словари могут получать именованные параметры через **-синтаксис<ref>''(Прим. перев.):''
<br /><br />
<code style="background-color: inherit !important;">'''опред''' попугай(вольтаж, состояние='труп', действие='ввум', тип='Норвежский Голубой'):<br/>
...&nbsp;&nbsp;&nbsp;&nbsp;'''вывести'''("-- Этот попугай не сделает ", действие, конец=' ')<br/>
...&nbsp;&nbsp;&nbsp;&nbsp;'''вывести'''("если вы пропустите через него ", вольтаж, " вольт.", конец=' ')<br/>
...&nbsp;&nbsp;&nbsp;&nbsp;'''вывести'''("-- Это", состояние, "!")<br/>
...<br/>
>>> d = {"вольтаж": "четыре миллиона", "состояние": "кровавая кончина", "действие": "ВВУМ"}<br/>
>>> попугай(**d)<br/>
-- Этот попугай не сделает ВВУМ если вы пропустите через него четыре миллиона вольт. Это кровавая смерть !</code><br /><br />
(''Из [http://www.ibras.dk/montypython/episode08.htm#6 скетча Монти Пайтона]'')</ref>:

<syntaxhighlight lang="python">>>> def parrot(voltage, state='a stiff', action='voom'):
...     print("-- This parrot wouldn't", action, end=' ')
...     print("if you put", voltage, "volts through it.", end=' ')
...     print("It's", state, "!")
...
>>> d = {"voltage": "four million", "state": "bleedin' demised", "action": "VOOM"}
>>> parrot(**d)
-- This parrot wouldn't VOOM if you put four million volts through it. It's bleedin' demised !</syntaxhighlight>

==== Модель <tt>lambda</tt> ====

В связи с неустанными просьбами, в Python были добавлены несколько возможностей, которые были привычны для функциональных языков программирования, таких как Lisp. Используя зарезервированное слово <code>lambda</code>, вы можете создать небольшую безымянную функцию. Например, функцию, которая возвращает сумму двух своих аргументов, можно записать так: <code>lambda a, b: a+b</code>. Формы <code>lambda</code> могут быть использованы в любом месте где требуется объект функции. При этом они синтаксически ограничены одним выражением. Семантически, они лишь «синтаксический сахар» для обычного определения функции. Как и определения вложенных функций, <code>lambda</code>-формы могут ссылаться на переменные из содержащей их области видимости:

<syntaxhighlight lang="python">>>> def make_incrementor(n):
...     return lambda x: x + n
...
>>> f = make_incrementor(42)
>>> f(0)
42
>>> f(1)
43</syntaxhighlight>

==== Строки документации ====

Перечислим некоторые существующие соглашения по содержимому строк документации и их форматированию.

По поводу форматирования строк документации и их содержимого постоянно появляются всё новые соглашения.

Первая строка всегда должна быть сжатой, лаконичной сводкой о назначении объекта. Для краткости, в ней не обязательно присутствие имени типа или объекта, поскольку они доступны другими способами (исключая случай, когда имя функции оказывается глаголом, описывающим суть операции). Эта строка должна начинаться с прописной буквы и оканчиваться точкой.

Если строке документации (литералу, объекту строки) требуется больше строк (физических), вторая строка должна быть пустой, визуально отделяя сводку от остального описания. Следующие строки могут быть одним или более абзацем, описывающим соглашения по вызову объекта, сторонние эффекты, и т. д.

Парсер Python не обрабатывает отступы в много-строковых литералах, поэтому инструментам, которые работают над документацией, предлагается, по желанию, делать это самим. Производится это по следующему соглашению. Первая непустая строка после первой строки литерала определяет величину отступа всего литерала документации. (Мы не можем использовать первую строку, поскольку она обычно выравнивается по открывающим кавычкам и её отступ в литерале не явен). Пробельный «эквивалент» этого отступа затем отрезается от начала всех строк литерала. Строк с меньшим отступом не должно обнаруживаться, но если они встретились, весь их начальный отступ должен быть обрезан. Эквивалентность пробельных замен может быть протестирована развертыванием табуляции (обычно, к 8 пробелам).

Вот пример многострочной документации (''док-строки''):

<syntaxhighlight lang="python">>>> def my_function():
...     """Не делаем ничего, но документируем.
...
...     Нет, правда, эта функция ничего не делает.
...     """
...     pass
...
>>> print(my_function.__doc__)
Не делаем ничего, но документируем.

    Нет, правда, эта функция ничего не делает.</syntaxhighlight>

=== Интермеццо: Стиль написания кода ===

Теперь, когда вам предстоит писать более объёмные и сложные блоки кода на Python, настало время поговорить о ''стиле написания кода'' (<tt>coding style</tt>). Код на большинстве языков программирования может быть записан (или, точнее говоря, ''отформатирован'' (<tt>formatted</tt>)) различными способами; некоторые из них более читабельны, некоторые — нет. Стремление к написанию лёгкого для прочтения другими кода всегда считалось хорошим тоном, и выбор правильного стиля для кода крайне ему способствует.

В случае языка Python, в качестве руководства по стилю было создано предложение [http://www.python.org/dev/peps/pep-0008 PEP8]<ref>''(Прим. перев.)'' — <tt>[[w:Python_Enhancement_Proposal|PEP]]</tt> (</tt>''Python Enchancement Proprosal</tt>'', Предложение по улучшению Python) — документ, имеющий стандартизированный формат и описывающий какую-либо из возможностей или какое-либо из свойств языка Python, планируемые для разработки в будущем (или уже разработанную). В завершённом варианте используется как основное соглашение по данной функциональности. (см. также [[w:Python#Дальнейшая разработка|пояснение на странице языка Python]])</ref>, которого придерживаются создатели большинства проектов. В нём учреждается чрезвычайно читабельный и приятный для глаза стиль написания кода. В некоторый момент с ним должен ознакомиться каждый разработчик на Python. Приведём здесь избранные, наиболее важные, пункты:

* Используйте отступ в 4 пробела, не используйте табуляцию
: 4 пробела легко опознаются и в случае небольших отступов (хватает места для глубоких вложений) и в случае больших отступов (приятнее читается). Табуляция вносит путаницу и лучше от неё воздержаться.
* Разделяйте строки так, чтобы их длина не превышала 79-и символов
: Это поможет пользователям с небольшими экранами, а пользователям с большими экранами позволит уложить несколько файлов с исходным кодом рядом.
* Используйте пустые строки для отделения функций, классов, и крупных блоков внутри функций.
* При возможности располагайте комментарий на отдельной строке.
* Используйте строки документации (''док-строки'')
* Применяйте пробелы вокруг символов операций и после запятых, но не добавляйте их в конструкции со скобками: <code>a = f(1, 2) + g(3, 4)</code>
* Называйте ваши классы и функции единообразно; соглашение следующее: используйте <code>CamelCase</code><ref>''(Прим. перев.)'' <tt>CamelCase</tt> (''ВерблюжийСтиль'') — стиль именования идентификаторов, при котором все слова, записанные строчными буквами, объединяются в одно и первая буква каждого слова выделяется заглавной буквой — такая запись напоминает верблюжьи горбы, в связи с чем и названа.</ref> для именования классов и <code>нижний_регистр_с_подчёркиваниями</code></tt><ref>''(Прим. перев.)'' Пусть данный пример по вине переводчика и использует русские буквы, соглашение корректно настаивает на использовании латиницы для именования идентификаторов, см. следующий пункт соглашения</ref> для функций и методов. (обращайтесь к разделу [[Учебник Python 3.1#Первый взгляд на классы|Первый взгляд на классы]] за дополнительной информацией о классах и методах)
* Не используйте в вашем коде изощрённых кодировок<ref>''(Прим. перев.)'' В строковых литералах (не комментариях) это, конечно же, позволено</ref>, если он рассчитан на использование в интернациональной среде. Стандартный набор ASCII всегда работает на ура<ref>''(Прим. перев.)'' Не кодировка, а именно набор символов — латиница, пунктуация и несколько служебных символов. Кодировка по умолчанию для файлов с иходными кодами, начиная с Python 3.0, всегда UTF-8 — дабы существовала возможность использовать национальные символы в строковых литералах и, в редких случаях — комментариях.</ref>.

