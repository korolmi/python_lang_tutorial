
== Ввод и вывод ==

Ознакомить пользователя с выводом программы можно различными способами — данные могут быть выведены в читаемом виде или записаны в файл для последующего использования. Часть возможностей будет обсуждена в этой главе.

=== Удобное форматирование вывода ===

На данный момент мы выяснили два способа вывода значений: ''операторные выражения'' (<tt>expression statements</tt>) и функция <code>print()</code>. (Третий способ — использование метода <code>write()</code> объектов файлов; на файл стандартного вывода можно сослаться как на <code>sys.stdout</code>. Более подробную информацию по этому пункту смотрите в [[Справочник по библиотеке Python 3.1|Справочнике по библиотеке]].)

Часто возникает желание иметь больший контроль над форматированием вывода, чем обычная печать значений разделённых пробелами. Есть два способа форматирования вашего вывода. Первый способ — выполнять самостоятельно всю работу над строками: используя срезы строк и конкатенацию вы можете создать любой шаблон, какой пожелаете. Стандартный модуль <code>string</code> содержит много полезных операций для выравнивания строк по определённой ширине колонки (скоро мы их кратко рассмотрим). Второй способ — использование метода <code>str.format()</code>.

Модуль <code>string</code> содержит класс <code>Template</code>, который предоставляет ещё один способ подстановки значений в строки.

Остаётся, конечно, один вопрос: каким образом конвертировать значения в строки? К счастью, в Python есть два способа для преобразования любого значения в строку — это функции <code>repr()</code> и <code>str()</code>.

Предназначение функции <code>str()</code> — возврат значений в довольно-таки читабельной форме; в отличие от <code>repr()</code>, чьё назначение — генерирование форм<ref>(''Прим. перев.'') ''representation'' {{ref-en}} — представление, образ, форма</ref>, которые могут быть прочитаны интерпретатором (или вызовут ошибку <code>SyntaxError</code>, если эквивалентного синтаксиса не существует). Для тех объектов, у которых нет формы для человеческого прочтения функция <code>str()</code> возвратит такое же значение, как и <code>repr()</code>. У многих значений, таких как числа или структуры, вроде списков и словарей, одинаковая форма для обеих функций. Строки и числа с плавающей точкой, в частности, имеют по две разных формы.

Несколько примеров:

<syntaxhighlight lang="python">>>> s = 'Привет, мир.'
>>> str(s)
'Привет, мир.'
>>> repr(s)
"'Привет, мир.'"
>>> str(0.1)
'0.1'
>>> repr(0.1)
'0.10000000000000001'
>>> x = 10 * 3.25
>>> y = 200 * 200
>>> s = 'Значение x - ' + repr(x) + ', а y - ' + repr(y) + '...'
>>> print(s)
Значение x - 32.5, а y - 40000...
>>> # Функция repr(), применённая к строке, добавляет кавычки и обратные слэши:
... hello = 'привет, мир\n'
>>> hellos = repr(hello)
>>> print(hellos)
'привет, мир\n'
>>> # Параметром функции repr() может быть объект Python:
... repr((x, y, ('фарш', 'яйца')))
"(32.5, 40000, ('фарш', 'яйца'))"</syntaxhighlight>

Вот два способа вывести таблицу квадратов и кубов:

<syntaxhighlight lang="python">>>> for x in range(1, 11):
...     print(repr(x).rjust(2), repr(x*x).rjust(3), end=' ')
...     # Обратите внимание на использование end в предыдущей строке
...     print(repr(x*x*x).rjust(4))
...
 1   1    1
 2   4    8
 3   9   27
 4  16   64
 5  25  125
 6  36  216
 7  49  343
 8  64  512
 9  81  729
10 100 1000

>>> for x in range(1, 11):
...     print('{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x))
... 
 1   1    1
 2   4    8
 3   9   27
 4  16   64
 5  25  125
 6  36  216
 7  49  343
 8  64  512
 9  81  729
10 100 1000</syntaxhighlight>

(Обратите внимание, что в первом примере единичные пробелы между колонками добавлены функцией <code>print()</code>: она всегда вставляет пробелы между своими параметрами)

Этот пример демонстрирует работу метода строковых объектов <code>rjust()</code>, выравнивающего строку по правому краю в поле переданной ширины, отступая пробелами слева. Имеются также похожие методы <code>ljust()</code> и <code>center()</code>. Эти методы не выводят ничего, они лишь возвращают новую строку. Если строка на входе чересчур длинная, то они не усекают её, что обычно является меньшим из зол. (Для усечения можно добавить операцию среза, например: <code>x.ljust(n)[:n]</code>.)

Есть другой метод — <code>zfill()</code>, который заполняет нулями пространство слева от числовой строки. Он распознаёт знаки плюс и минус:

<syntaxhighlight lang="python">>>> '12'.zfill(5)
'00012'
>>> '-3.14'.zfill(7)
'-003.14'
>>> '3.14159265359'.zfill(5)
'3.14159265359'</syntaxhighlight>

Основной способ применения метода <code>str.format()</code> выглядит так<ref>''(Прим. перев.)'' We are the knights who say «Ni!» (''Мы — те рыцари, что говорят «Ни!»'') — цитата из [http://www.mwscomp.com/movies/grail/grail-13.htm сцены 13-й] фильма Монти Пайтон и Святой Грааль (Monty Python and Holy Grail)</ref>:

<syntaxhighlight lang="python">>>> print('Мы — те {0}, что говорят "{1}!"'.format('рыцари', 'Ни'))
Мы — те рыцари, что говорят "Ни!"</syntaxhighlight>

Скобки с символами внутри (их называют ''полями форматирования'' (<tt>format fields</tt>)) заменяются на объекты, переданные методу <code>format</code>. Номер в скобках обозначает позицию объекта в списке параметров, переданных методу <code>format</code>.

<syntaxhighlight lang="python">>>> print('{0} и {1}'.format('фарш', 'яйца'))
фарш и яйца
>>> print('{1} и {0}'.format('фарш', 'яйца'))
яйца и фарш</syntaxhighlight>

Если в методе <code>format</code> используются именованные параметры, можно ссылаться на их значения, используя имя соответствующего аргумента<ref>''(Прим. перев.)'' <tt>вывести('Этот {пища} — {прилагательное}.'.format(пища='фарш', прилагательное='непередаваемо ужасен'))</tt></ref>.

<syntaxhighlight lang="python">>>> print('Этот {food} — {adjective}.'.format(
...       food='фарш', adjective='непередаваемо ужасен'))
Этот фарш — непередаваемо ужасен.</syntaxhighlight>

Позиционные и именованные параметры можно произвольно совмещать<ref>''(Прим. перев.)'' <tt>вывести('История о {0}, {1}, и {другой}.'.format('Билл', 'Манфред', другой='Георг'))</tt></ref>:

<syntaxhighlight lang="python">>>> print('История о {0}е, {1}е, и {other}е.'.format('Билл', 'Манфред',
                                                       other='Георг'))
История о Билле, Манфреде, и Георге.</syntaxhighlight>

После имени поля может следовать необязательный спецификатор формата ‘<code>:</code>’. С его помощью можно управлять форматированием значения. Следующий пример оставляет у числа Пи только три цифры после десятичного разделителя<ref>''(Прим. перев.)'' В качестве десятичного разделителя в Python используется точка, в соответствии со стандартами большинства стран.</ref>.

<syntaxhighlight lang="python">>>> import math
>>> print('Значение ПИ — примерно {0:.3f}.'.format(math.pi))
Значение ПИ — примерно 3.142.</syntaxhighlight>

После спецификатора ‘<code>:</code>’ можно указать число — минимальную ширину поля, выраженную в количестве символов. Это удобно использовать для создания красивых таблиц:

<syntaxhighlight lang="python">>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
>>> for name, phone in table.items():
...     print('{0:10} ==> {1:10d}'.format(name, phone))
... 
Jack       ==>       4098
Dcab       ==>       7678
Sjoerd     ==>       4127</syntaxhighlight>

Если ваша строка с форматами очень длинна, а вы не хотите разбивать её на подстроки, было бы неплохо если бы вы могли ссылаться на переменные, предназначенные для форматирования, не по позиции, а по имени. Это можно сделать, просто передав словарь и используя квадратные скобки ‘<tt>[]</tt>’ для доступа к ключам.

<syntaxhighlight lang="python">>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
>>> print('Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; '
          'Dcab: {0[Dcab]:d}'.format(table))
Jack: 4098; Sjoerd: 4127; Dcab: 8637678</syntaxhighlight>

Тоже самое можно сделать, передав словарь именованных параметров, используя нотацию «<code>**</code>»:

<syntaxhighlight lang="python">>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
>>> print('Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; Dcab: {Dcab:d}'.format(**table))
Jack: 4098; Sjoerd: 4127; Dcab: 8637678</syntaxhighlight>

В частности, такой приём удобно использовать в сочетании со встроенной функцией <code>vars()</code>, которая возвращает словарь с локальными переменными.

Подробное описание форматирования строк с применением метода <code>str.format()</code> описано в разделе [[Справочник по библиотеке Python 3.1#Синтаксис строк форматирования|Синтаксис строк форматирования]].

==== Форматирование строк в старом стиле ====

Для форматирования строк можно использовать и операцию <code>%</code>. Она интерпретирует левый операнд как строку форматирования в стиле <code>sprintf</code>, которую следует применить к правому операнду, и возвращает строку, получившуюся в результате этого преобразования. Например:

<syntaxhighlight lang="python">>>> import math
>>> print 'Значение ПИ — примерно %5.3f.' % math.pi
Значение ПИ — примерно 3.142.</syntaxhighlight>

Поскольку метод <code>str.format()</code> довольно нов, большая часть исходных кодов Python всё ещё использует операцию <code>%</code>. Однако, со временем, форматирование строк будет удалено из языка, поэтому в большинстве случаев следует использовать <code>str.format()</code>.

Больше информации можно найти в разделе [[Справочник по библиотеке Python 3.1#Операции форматирования строк в старом стиле|Операции форматирования строк в старом стиле]].

=== Запись и чтение файлов ===

Функция <code>open()</code> возвращает объект файла и в большинстве случаев используется с двумя аргументами: <code>open(''имя_файла'', ''режим'')</code>.

<syntaxhighlight lang="python">>>> f = open('/tmp/workfile', 'w')</syntaxhighlight>

Первый параметр — строка, содержащая имя файла. Второй — другая строка, содержащая несколько символов, описывающих способ использования файла. Значение параметра ''режим'' может быть символом <code>'r'</code>, если файл будет открыт только для чтения, <code>'w'</code> — открыт только для записи (существующий файл с таким же именем будет стёрт) и <code>'a'</code> — файл открыт для добавления: любые данные, записанные в файл автоматически добавляются в конец. <code>'r+'</code> открывает файл и для чтения, и для записи. Параметр ''режим'' необязателен: если он опущен — предполагается, что он равен <code>'r'</code>.

В обычном случае файлы открываются в ''текстовом режиме'' (<tt>text mode</tt>) — это значит что вы читаете из файла и записываете в файл строки в определённой кодировке (по умолчанию используется <tt>UTF-8</tt>). Если добавить к режиму файла символ ‘<code>b</code>’, файл открывается в ''двоичном режиме'' (<tt>binary mode</tt>): теперь данные считываются и записываются в виде двоичных объектов. Этот режим следует использовать для всех файлов, которые не содержат текст.

При использовании текстового режима, все окончания строк, по умолчанию, специфичные для платформы (<code>\n</code> в Unix, <code>\r\n</code> в Windows) усекаются до символа <code>\n</code>, при чтении из файла, и конвертируются обратно из <code>\n</code> в вид, специфичный для платформы, при записи в файл. Эти закулисные изменения в файловых данных корректно работают в случае текстовых файлов, но испортят двоичные данные в файлах вроде <code>JPEG</code> или <code>EXE</code>. Внимательно следите за тем, чтобы использовать двоичный режим при чтении и записи таких файлов.

==== Методы объектов-файлов ====

В примерах ниже подразумевается, что заранее создан файловый объект с именем <code>f</code>.

Чтобы прочитать содержимое файла, вызовите <code>f.read(''размер'')</code> — функция читает некоторое количество данных и возвращает их в виде строки или байтового объекта. <code>''размер''</code> — необязательный числовой параметр. Если <code>''размер''</code> опущен или отрицателен, будет прочитано и возвращено всё содержимое файла; если файл по величине в два раза больше оперативной памяти вашего компьютера, то решение этой проблемы остаётся на вашей совести. В противном случае, будет прочитано и возвращено максимум <code>''размер''</code> байт. Если был достигнут конец файла, <code>f.read()</code> вернёт пустую строку (<code>''</code>).

<syntaxhighlight lang="python">>>> f.read()
'Это всё содержимое файла.\n'
>>> f.read()
''</syntaxhighlight>

<code>f.readline()</code> читает одну строку из файла; символ новой строки (<code>\n</code>) остаётся в конце прочитанной строки и отсутствует при чтении последней строки файла только если файл не оканчивается пустой строкой. За счёт этого возращаемое значение становится недвусмысленным: если <code>f.readline()</code> возвращает пустую строку — достигнут конец файла, в то же время незаполненная строка, представленная посредством <code>'\n'</code>, содержит лишь символ новой строки.<ref>''(Прим. перев.)'' В источнике, в большинстве случаев, разделяется понятие ''строки'' как типа данных и ''строки'' как строки текста (ср., ''строчка'') применением слов ''string'' и ''line'' соответственно. В русском языке это различие передать сложно, тем не менее я старался по возможности избежать двусмысленностей.</ref>

<syntaxhighlight lang="python">>>> f.readline()
'Это первая строка файла.\n'
>>> f.readline()
'Вторая строка файла\n'
>>> f.readline()
''</syntaxhighlight>

<code>f.readlines()</code> возвращает список, содержащий все строки с данными, обнаруженные в файле. Если передан необязательный параметр <code>подсказка_размера</code>, функция читает из файла указанное количество байт, плюс некоторое количество байт сверх того, достаточное для завершения строки, и формирует список строк из результата. Функция часто используется для более эффективного (файл не загружается в память полностью) построчного чтения больших файлов. Возвращены будут только полные (завершённые) строки.

<syntaxhighlight lang="python">>>> f.readlines()
['Это первая строка файла.\n', 'Вторая строка файла\n']</syntaxhighlight>

Альтернативный способ построчного чтения — организация цикла по файловому объекту. Он быстр, рационально использует память и имеет простой код в результате:

<syntaxhighlight lang="python">>>> for line in f:
        print(line, end='')
        
Это первая строка файла.
Вторая строка файла</syntaxhighlight>

Альтернативный способ проще, но не предоставляет тонкого контроля над происходящим. Поскольку оба этих способа работают с буферизацией строк по-разному, их не следует смешивать.

<code>f.write(''строка'')</code> записывает содержимое ''строки'' в файл и возвращает количество записанных байтов.

<syntaxhighlight lang="python">>>> f.write('This is a test\n')
15</syntaxhighlight>

Чтобы записать в файл нечто отличное от строки, предварительно это нечто нужно в строку сконвертировать<ref>''(Прим. перев.)'' Возможно, подразумевается [[w:ru:Ответ на главный вопрос жизни, вселенной и всего такого|ответ на главный вопрос жизни, вселенной и всего такого]]</ref>:

<syntaxhighlight lang="python">>>> value = ('ответ', 42)
>>> s = str(value)
>>> f.write(s)
18</syntaxhighlight>

<code>f.tell()</code> возвращает целое, представляющее собой текущую позицию в файле <code>f</code>, измеренную в байтах от начала файла. Чтобы изменить позицию объекта-файла, используйте <code>f.seek(''смещение'', ''откуда'')</code>. Позиция вычисляется прибавлением смещения к точке отсчёта; точка отсчёта выбирается из параметра <code>''откуда''</code>. Значение <code>0</code> параметра <code>''откуда''</code> отмеряет смещение от начала файла, значение <code>1</code> применяет текущую позицию в файле, а значение <code>2</code> в качестве точки отсчёта использует конец файла. Параметр <code>''откуда''</code> может быть опущен и по умолчанию устанавливается в <code>0</code>, используя начало файла в качестве точки отсчёта.

<syntaxhighlight lang="python">>>> f = open('/tmp/workfile', 'rb+')
>>> f.write(b'0123456789abcdef')
16
>>> f.seek(5)     # Перейти к шестому байту в файле
5
>>> f.read(1)        
b'5'
>>> f.seek(-3, 2) # Перейти к третьему байту с конца 
13
>>> f.read(1)
b'd'</syntaxhighlight>

При работе с текстовыми файлами (открытыми без символа <code>b</code> в строке режима), выполнять позиционирование (<code>seek</code>) позволяется только от начала файла (за исключением прокрутки в конец файла с использованием <code>seek(0, 2)</code>).

Когда вы закончили все действия над файлом, вызовите <code>f.close()</code> чтобы закрыть его и освободить все системные ресурсы, использованные при открытии этого файла. Все попытки использовать объект-файл после вызова <code>f.close()</code> приведут к возникновению исключения.

<syntaxhighlight lang="python">>>> f.close()
>>> f.read()
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
ValueError: I/O operation on closed file</syntaxhighlight>

Считается хорошей манерой использовать ключевое слово <code>with</code> при работе с файловыми объектами. Преимущество этого способа в том, что файл всегда корректно закрывается после выполнения блока, либо если при выполнении было порождено исключение. Кроме того, получающийся код намного короче, чем эквивалентная форма с блоками <tt><code>try</code>-<code>finally</code></tt>:

<syntaxhighlight lang="python">>>> with open('/tmp/workfile', 'r') as f:
...     read_data = f.read()
>>> f.closed
True</syntaxhighlight>

У объектов-файлов есть ещё несколько дополнительных методов, таких как <code>isatty()</code> и <code>truncate()</code>, которые используются не так часто; обратитесь к [[Справочник по библиотеке Python 3.1|Справочнику по библиотеке]] для более полного обзора по файловым объектам.

==== Модуль <code>pickle</code> ====

Строки могут с лёгкостью быть записаны в файл и прочитаны из файла. В случае чисел нужно применить несколько больше усилий: метод <code>read()</code> возвращает только строки, которые придётся передать функции вроде <code>int()</code>, которая принимает строку вида <code>'123'</code> и возвращает её числовое значение: <code>123</code>. Однако если вы намереваетесь сохранить более сложные типы данных, такие как списки, словари или экземпляры классов, всё становится несколько запутаннее.

Вместо того чтобы принуждать программиста постоянно писать и отлаживать код для замысловатых типов данных, Python предоставляет стандартный модуль под названием <code>pickle</code>. Это замечательный модуль, который может принять любой объект Python (даже некоторые формы кода на Python!) и конвертировать его в строковое представление: этот процесс называется ''консервацией'' (<tt>pickling</tt>). Восстановление объекта из его строкового представления называется ''расконсервацией'' (<tt>unpickling</tt>): строка, описывающая объект, может быть сохранена в файл, добавлена к некоторым данным, или отослана через соединение по сети на удаленный компьютер.<ref>''(Прим. перев.)'' ''Консервирование'' в Python можно рассматривать как частный случай [[w:ru:Сериализация|сериализации]]; ещё про ''консервирование'' можно почитать [http://www.ibm.com/developerworks/ru/library/l-pypers/index.html здесь].</ref>

Если у вас есть некоторый объект <code>x</code> и объект файла <code>f</code>, открытый на запись в двоичном режиме (binary mode, с параметром 'wb'), простейший способ ''законсервировать'' объект требует одной-единственной строки кода:

<syntaxhighlight lang="python">pickle.dump(x, f)</syntaxhighlight>

Чтобы снова расконсервировать объект, при условии что <code>f</code> — объект файла, открытого для чтения (так же в двоичном режиме, с параметром 'rb'):

<syntaxhighlight lang="python">x = pickle.load(f)</syntaxhighlight>

(Существуют варианты выполнения этих операций, применяемые при ''расконсервации'' нескольких объектов или когда вам требуется записать ''консервированные'' данные в файл; обратитесь к документации по модулю [[Справочник по библиотеке Python 3.1#pickle|pickle]] из [[Справочник по библиотеке Python 3.1|Справочника по библиотеке]].)

[[Справочник по библиотеке Python 3.1#pickle|pickle]] — стандартный способ для создания объектов Python, которые могут быть повторно использованы другими программами или будущими версиями этой же программы; для них есть технический термин — ''устойчивый объект'' (<tt>persistent object</tt>). Поскольку [[Справочник по библиотеке Python 3.1#pickle|pickle]] используется часто, многие авторы расширений для Python заботятся о том, чтобы новые типы данных, такие как матрицы, могли быть корректно ''законсервированы'' и ''расконсервированы''.

