
== Структуры данных ==

Эта глава описывает подробнее некоторые вещи, которые вы уже изучили, а также раскрывает некоторые новые темы.

=== Подробнее о списках ===

У типа данных список также имеются не описанные ранее методы. Ниже приведены все методы объекта типа список:

;<code>list.append(''x'')</code>:Добавить элемент к концу списка; эквивалент <code>list[len(list):] = [x]</code>

;<code>list.extend(''L'')</code>:Расширить список за счёт добавления всех элементов переданного списка; эквивалентно <code>list[len(list):] = L</code>.

;<code>list.insert(''i'', ''x'')</code>:Вставить элемент в указанную позицию. Первый аргумент — это индекс того элемента, перед которым требуется выполнить операцию вставки, поэтому вызов <code>list.insert(0, x)</code> вставляет элемент в начало списка, а <code>list.insert(len(list), x)</code> эквивалентно <code>list.append(x)</code>.

;<code>list.remove(''x'')</code>:Удалить первый найденный элемент из списка, значение которого — <code>x</code>. Если элемент не найден, генерируется ошибка.

;<code>list.pop([''i''])</code>:Удалить элемент, находящийся на указанной позиции в списке, и вернуть его. Если индекс не указан, <code>list.pop()</code> удаляет и возвращает последний элемент списка. (Квадратные скобки вокруг <code>i</code> в сигнатуре метода означают, что параметр необязателен, а не необходимость набора квадратных скобок в этой позиции. Вы часто будете встречать такую нотацию в [[Справочник по библиотеке Python 3.1|Справочнике по библиотеке]].)

;<code>list.index(''x'')</code>:Вернуть индекс первого найденного в списке элемента, значение которого равно <code>x</code>. Если элемент не найден, генерируется ошибка.

;<code>list.count(''x'')</code>:Вернуть значение сколько раз, <code>x</code> встречается в списке.

;<code>list.sort()</code>:Сортировать элементы списка, на месте.

;<code>list.reverse()</code>:Обратить порядок элементов списка, на месте.

Пример, использующий большинство методов списка:

<syntaxhighlight lang="python">>>> a = [66.25, 333, 333, 1, 1234.5]
>>> print(a.count(333), a.count(66.25), a.count('x'))
2 1 0
>>> a.insert(2, -1)
>>> a.append(333)
>>> a
[66.25, 333, -1, 333, 1, 1234.5, 333]
>>> a.index(333)
1
>>> a.remove(333)
>>> a
[66.25, -1, 333, 1, 1234.5, 333]
>>> a.reverse()
>>> a
[333, 1234.5, 1, 333, -1, 66.25]
>>> a.sort()
>>> a
[-1, 1, 66.25, 333, 333, 1234.5]</syntaxhighlight>

==== Использование списка в качестве стека ====

Методы списков позволяют легко использовать список в качестве стека, где последний добавленный элемент становится первым полученным («первый вошёл — последний вышел»). Чтобы положить элемент на вершину стека, используйте метод <code>append()</code>. Для получения элемента с вершины стека — метод <code>pop()</code> без указания явного индекса. Например:

<syntaxhighlight lang="python">>>> stack = [3, 4, 5]
>>> stack.append(6)
>>> stack.append(7)
>>> stack
[3, 4, 5, 6, 7]
>>> stack.pop()
7
>>> stack
[3, 4, 5, 6]
>>> stack.pop()
6
>>> stack.pop()
5
>>> stack
[3, 4]</syntaxhighlight>

==== Использование списка в качестве очереди ====

Вы можете без труда использовать список также и в качестве очереди, где первый добавленный элемент оказывается первым полученным («первый вошёл — первый вышел»). Чтобы добавить элемент в конец очереди, используйте метод <code>append()</code>, а чтобы получить элемент из начала очереди — метод <code>pop()</code> с нулём в качестве индекса. Например:

<syntaxhighlight lang="python">>>> queue = ["Eric", "John", "Michael"]
>>> queue.append("Terry")           # Прибыл Terry
>>> queue.append("Graham")          # Прибыл Graham
>>> queue.pop(0)
'Eric'
>>> queue.pop(0)
'John'
>>> queue
['Michael', 'Terry', 'Graham']</syntaxhighlight>

==== Генераторы списков<ref>''(Прим. перев.)'' ''Lists Comprehensions'', comprehension — включение, вложение, добавление (понимание, охват, интенция).</ref> ====

Использование метода списковой сборки — легкий способ создать список на основе последовательности. В большинстве случаев он применяется для создания списков, в которых каждый элемент является результатом некой операции, произведённой над каждым членом последовательности, или для создания выборок из тех элементов, которые удовлетворяют определённому условию.

Любая списковая сборка состоит из выражения, за которым следует оператор <code>for</code>, а затем ноль или более операторов <code>for</code> или <code>if</code>. Результатом станет список, получившийся через вычисление выражения в контексте следующих за ним операторов <code>for</code> и/или <code>if</code>. Если в результате вычисления выражения строится кортеж, его нужно явно обернуть в скобки.

В следующем примере на основе списка чисел создаётся список, где каждое число утроено:

<syntaxhighlight lang="python">>>> vec = [2, 4, 6]
>>> [3*x for x in vec]
[6, 12, 18]</syntaxhighlight>

Применим фантазию:

<syntaxhighlight lang="python">>>> [[x, x**2] for x in vec]
[[2, 4], [4, 16], [6, 36]]</syntaxhighlight>

Здесь мы вызываем метод по очереди с каждым элементом последовательности:

<syntaxhighlight lang="python">>>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']
>>> [weapon.strip() for weapon in freshfruit]
['banana', 'loganberry', 'passion fruit']</syntaxhighlight>

Используя оператор <code>if</code>, мы можем отфильтровать поток:

<syntaxhighlight lang="python">>>> [3*x for x in vec if x > 3]
[12, 18]
>>> [3*x for x in vec if x < 2]
[]</syntaxhighlight>

Кортежи могут быть созданы без использования скобок, но не в этом случае:

<syntaxhighlight lang="python">>>> [x, x**2 for x in vec]   # ошибка - для кортежей необходимы скобки
File "<stdin>", line 1, in ?
 [x, x**2 for x in vec]
           ^
SyntaxError: invalid syntax
>>> [(x, x**2) for x in vec]
[(2, 4), (4, 16), (6, 36)]</syntaxhighlight>

Вот несколько вложенных циклов <code>for</code> и ещё кое-какое забавное поведение:

<syntaxhighlight lang="python">>>> vec1 = [2, 4, 6]
>>> vec2 = [4, 3, -9]
>>> [x*y for x in vec1 for y in vec2]
[8, 6, -18, 16, 12, -36, 24, 18, -54]
>>> [x+y for x in vec1 for y in vec2]
[6, 5, -7, 8, 7, -5, 10, 9, -3]
>>> [vec1[i]*vec2[i] for i in range(len(vec1))]
[8, 12, -54]</syntaxhighlight>

Списковые сборки могут применяться в сложных выражениях и вложенных функциях<ref>''(Прим. перев.)'' в Python, как и в большинстве других языков программирования, используется европейский стандарт разделения целой и дробной части десятичных дробей точкой.</ref>:

<syntaxhighlight lang="python">>>> [str(round(355/113, i)) for i in range(1, 6)]
['3.1', '3.14', '3.142', '3.1416', '3.14159']</syntaxhighlight>

==== Вложенные списковые сборки ====

Если вы в состоянии это переварить: списковые сборки могут быть вложенными. Но как любой мощный инструмент, их следует использовать с осторожностью.

Представьте нижеследующий пример матрицы 3x3 в виде списка, содержащего три других списка, по одному в ряд:

<syntaxhighlight lang="python">>>> mat = [
...        [1, 2, 3],
...        [4, 5, 6],
...        [7, 8, 9],
...       ]</syntaxhighlight>

Чтобы поменять строки и столбцы местами, можно использовать такую списковую сборку:

<syntaxhighlight lang="python">>>> print([[row[i] for row in mat] for i in [0, 1, 2]])
[[1, 4, 7], [2, 5, 8], [3, 6, 9]]</syntaxhighlight>

Применяя вложенные списковые сборки, необходимо помнить о важной вещи:

: Во избежание недоразумений при конструировании вложенных списковых сборок, читайте их справа налево.

Более многословная, с использованием операторов, версия примера может служить иллюстрацией:

<syntaxhighlight lang="python">for i in [0, 1, 2]:
    for row in mat:
        print(row[i], end="")
    print()</syntaxhighlight>

В реальных случаях лучше использовать встроенные функции вместо сложных выражений. В нашем случае поможет функция <code>zip()</code>:

<syntaxhighlight lang="python">>>> list(zip(*mat))
[(1, 4, 7), (2, 5, 8), (3, 6, 9)]</syntaxhighlight>

В разделе [[Учебник Python 3.1#Распаковка списков параметров|Распаковка списков параметров]] описано предназначение звёздочки в этих строках.

Другой пример использования вложенных списковых сборок — произведение матрицы a на матрицу b:

<syntaxhighlight lang="python">c=[[sum(x*y for x,y in zip(i,j)) for j in zip(*b)] for i in a]</syntaxhighlight>

Это можно сделать эффективнее и прозрачнее, но на данном примере видна мощь инструмента.

Получение единичной матрицы порядка n:

<syntaxhighlight lang="python">a=[[0]*i+[1]+[0]*(n-i-1) for i in range(n)]</syntaxhighlight>

=== Оператор <code>del</code> ===

Существует способ удалить элемент, указывая его индекс, а не его значение: оператор <code>del</code>. В отличие от метода <code>pop()</code>, он не возвращает значения. Оператор <code>del</code> может также использоваться для удаления срезов из списка или полной очистки списка (что мы делали ранее через присваивание пустого списка срезу). Например:

<syntaxhighlight lang="python">>>> a = [-1, 1, 66.25, 333, 333, 1234.5]
>>> del a[0]
>>> a
[1, 66.25, 333, 333, 1234.5]
>>> del a[2:4]
>>> a
[1, 66.25, 1234.5]
>>> del a[:]
>>> a
[]</syntaxhighlight>

<code>del</code> может быть также использован для удаления переменных полностью:

<syntaxhighlight lang="python">>>> del a</syntaxhighlight>

Ссылка на имя <code>a</code> в дальнейшем вызовет ошибку (по крайней мере до тех пор, пока с ним не будет связано другое значение). Позже мы с вами узнаем другие способы использования <code>del</code>.

=== Кортежи и последовательности ===

Мы видели, что списки и строки поддерживают много привычных свойств, таких как индексирование и операция получения срезов. Существует два подвида типов данных ''последовательность'' (<tt>sequence</tt>) (см. [[Справочник по библиотеке Python 3.1#Последовательности|Справочник по библиотеке — Последовательности]]), и поскольку Python — развивающийся язык, со временем могут быть добавлены другие последовательные типы данных. Итак, существует также и другой, достойный рассмотрения, стандартный последовательный тип данных: ''кортеж'' (<tt>tuple</tt>).

Кортеж состоит из некоторого числа значений разделённых запятыми, например:

<syntaxhighlight lang="python">>>> t = 12345, 54321, 'hello!'
>>> t[0]
12345
>>> t
(12345, 54321, 'hello!')
>>> # Кортежи могут быть вложенными:
... u = t, (1, 2, 3, 4, 5)
>>> u
((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))</syntaxhighlight>

Как видите, кортежи на выводе всегда заключены в скобки, таким образом вложенные кортежи интерпретируются корректно; они могут быть введены и с обрамляющими скобками и без, тем не менее в любом случае скобки чаще всего необходимы (если кортеж — часть более крупного выражения).

Кортежи можно использовать в различных целях. Например: <code>(x, y)</code> пары координат, записи о рабочих из базы данных, и так далее. Кортежи, как и строки, неизменяемы: невозможно присвоить что-либо индивидуальным элементам кортежа (однако, вы можете симулировать большинство схожих эффектов за счёт операций срезов и конкатенации). Также можно создать кортежи, содержащие изменяемые объекты, такие как списки.

Определённая проблема состоит в конструировании кортежей, состоящих из нуля или одного элемента: в синтаксисе языка есть дополнительные хитрости, позволяющие достигнуть этого. Пустые кортежи формируются за счёт пустой пары скобок; кортеж с одним элементом конструируется за счёт запятой, следующей за первым и единственным значением (его не обязательно заключать в скобки). Необычно, но эффективно. Например:

<syntaxhighlight lang="python">>>> empty = ()
>>> singleton = 'hello',    # <-- обратите внимание на замыкающую запятую
>>> len(empty)
0
>>> len(singleton)
1
>>> singleton
('hello',)</syntaxhighlight>

Выражение <code>t = 12345, 54321, 'hello!'</code> является примером ''упаковки кортежей'' (<tt>tuple packing</tt>): значения <code>12345</code>, <code>54321</code> и <code>'hello!'</code> упаковываются в кортеж вместе. Обратная операция также возможна:

<syntaxhighlight lang="python">>>> x, y, z = t</syntaxhighlight>

Такое действие называется, довольно удачно, ''распаковкой последовательности'' (<tt>sequence unpacking</tt>). Для распаковки на левой стороне требуется список переменных с количеством элементов равным длине последовательности. Обратите внимание, что множественное присваивание на самом деле является лишь комбинацией упаковки кортежа и распаковки последовательности.

Здесь есть некоторая асимметрия: упаковка нескольких значений всегда создаёт кортеж, а распаковка работает для любой последовательности.

=== Множества ===

Python имеет также тип данных ''множество'' (<tt>set</tt>). Множество — это неупорядоченная коллекция без дублирующихся элементов. Основные способы использования — проверка на вхождение и устранение дублирующихся элементов. Объекты этого типа поддерживают обычные математические операции над множествами, такие как объединение, пересечение, разность и симметрическая разность.

Для создания множеств могут быть использованы фигурные скобки или функция <tt>set()</tt>. ''Заметьте:'' Для создания пустого множества нужно использовать <code>set()</code>, а не <code>{}</code>: в последнем случае создаётся пустой ''словарь'' (<tt>dictionary</tt>) — тип данных, который мы обсудим в следующем разделе.

Продемонстрируем работу с множествами на небольшом примере<ref>''(Прим. перев.):''
<br /><br />
<code style="background-color: inherit !important;">>>> корзина = {'яблоко', 'апельсин', 'яблоко', 'груша', 'апельсин', 'банан'}<br/>
>>> ''вывести''(корзина)<br/>
{'апельсин', 'банан', 'яблоко', 'груша'}<br/>
>>> список_фруктов = ['яблоко', 'апельсин', 'яблоко', 'груша', 'апельсин', 'банан']<br/>
>>> фрукты = ''множество''(список_фруктов)&nbsp;&nbsp;&nbsp;&nbsp;# создать множество на основе данных из списка (заметьте исчезновение дубликатов -перев.)<br/>
>>> фрукты<br/>
{'апельсин', 'груша', 'яблоко', 'банан'}<br/>
>>> фрукты = {'апельсин', 'яблоко'}&nbsp;&nbsp;&nbsp;&nbsp;# синтаксис {} эквивалентен [] у списков<br/>
 >>> фрукты<br/>
 {'апельсин', 'яблоко'}<br/>
>>> 'апельсин' '''среди''' фрукты&nbsp;&nbsp;&nbsp;&nbsp;# быстрая проверка вхождения<br/>
Истина<br/>
>>> 'росичка' '''среди''' фрукты<br/>
Ложь</code><br /><br /></ref>:

<syntaxhighlight lang="python">>>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
>>> print(basket)
{'orange', 'banana', 'pear', 'apple'}
>>> fruit_list = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
>>> fruit = set(fruit_list)               # создать множество на основе данных из списка (заметьте исчезновение дубликатов -перев.)
>>> fruit
{'orange', 'pear', 'apple', 'banana'}
>>> fruit = {'orange', 'apple'}       # синтаксис {} эквивалентен [] у списков
>>> fruit
{'orange', 'apple'}
>>> 'orange' in fruit                 # быстрая проверка на вхождение
True
>>> 'crabgrass' in fruit
False</syntaxhighlight>

<syntaxhighlight lang="python">>>> # Демонстрация операций со множествами на примере букв из двух слов
...
>>> a = set('abracadabra')
>>> b = set('alacazam')
>>> a                                  # уникальные буквы в a
{'a', 'r', 'b', 'c', 'd'}
>>> a - b                              # буквы в a но не в b
{'r', 'd', 'b'}
>>> a | b                              # все буквы, которые встречаются в a или в b
{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}
>>> a & b                              # буквы, которые есть и в a и в b
{'a', 'c'}
>>> a ^ b                              # буквы в a или в b, но не в обоих
{'r', 'd', 'b', 'm', 'z', 'l'}</syntaxhighlight>

Как и у списков, у множеств существует синтаксис сборок:

<syntaxhighlight lang="python">>>> a = {x for x in 'abracadabra' if x not in 'abc'}
>>> a
{'r', 'd'}</syntaxhighlight>

=== Словари ===

Другой полезный встроенный в Python тип данных — это ''словарь'' (<tt>dictionary</tt>) (см. [[Справочник по библиотеке Python 3.1#Связывающие типы|Справочник по библиотеке — Связывающие типы]]). Словари иногда встречаются в других языках в виде «ассоциативных записей» или «ассоциативных массивов». В отличие от последовательностей, которые индексируются по диапазону чисел, словари индексируются по ''ключам'' (<tt>keys</tt>), которые, в свою очередь, могут быть любого неизменяемого типа; строки и числа всегда могут быть ключами. Кортежи могут быть ключами только если они составлены из строк, чисел или кортежей; если кортеж содержит какой-либо изменяемый объект, явно или неявно, то он не может быть использован в качестве ключа. Вы не можете использовать списки в роли ключей, поскольку списки могут быть изменены на месте присваиванием по индексу, присваиванием по срезу или такими методами как <code>append()</code> и <code>extend()</code>.

Лучше всего воспринимать словарь как неупорядоченный набор пар ''ключ: значение'' с требованием, чтобы ключи были уникальны (в пределах одного словаря). Пара скобок создает пустой словарь: <code>{}</code>. Указывая разделённый запятыми список пар ''ключ: значение'' внутри скобок, вы задаёте содержимое словаря; в таком же формате словарь можно вывести.

Главные операции над словарём — это сохранение значения с каким-либо ключом и извлечение значения по указанному ключу. Также возможно удалить пару ''ключ: значение'' используя оператор <code>del</code>. Если вы сохраняете значение используя ключ, который уже встречается в словаре — старое значение, ассоциированное с этим ключом, стирается. Извлечение значения по несуществующему ключу вызывает ошибку.

Выполнение конструкции <code>list(d.keys())</code> с объектом словаря возвращает список всех ключей, использующихся в словаре, в случайном порядке (если вы хотите отсортировать его, к списку ключей можно применить функцию <code>sorted()</code>). Чтобы проверить, содержит ли словарь определённый ключ, используйте ключевое слово <code>in</code>.

Вот небольшой пример использования словарей:

<syntaxhighlight lang="python">>>> tel = {'jack': 4098, 'sape': 4139}
>>> tel['guido'] = 4127
>>> tel
{'sape': 4139, 'guido': 4127, 'jack': 4098}
>>> tel['jack']
4098
>>> del tel['sape']
>>> tel['irv'] = 4127
>>> tel
{'guido': 4127, 'irv': 4127, 'jack': 4098}
>>> list(tel.keys())
['irv', 'guido', 'jack']
>>> sorted(tel.keys())
['guido', 'irv', 'jack']
>>> 'guido' in tel
True
>>> 'jack' not in tel
False</syntaxhighlight>

Конструктор <code>dict()</code> строит словарь непосредственно на основе пар ключей и значений, где каждая пара представлена в виде кортежа. Когда пары могут быть сформированы шаблоном, ''списковые сборки'' помогут описать список пар более компактно.

<syntaxhighlight lang="python">>>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
{'sape': 4139, 'jack': 4098, 'guido': 4127}</syntaxhighlight>

В дополнение ко всему этому, для создания словарей из произвольных выражений для ключей и значений, могут быть использованы словарные сборки:

<syntaxhighlight lang="python">>>> {x: x**2 for x in (2, 4, 6)}
{2: 4, 4: 16, 6: 36}</syntaxhighlight>

Позже в учебнике мы изучим выражения-генераторы (<tt>Generator Expressions</tt>), которые даже лучше подходят для снабжения конструктора <code>dict()</code> парами ключ-значение.

Если ключи являются простыми строками, иногда легче описать пары используя именованные параметры:

<syntaxhighlight lang="python">>>> dict(sape=4139, guido=4127, jack=4098)
{'sape': 4139, 'jack': 4098, 'guido': 4127}</syntaxhighlight>

=== Организация циклов ===

При организации перебора элементов из словаря ключ и соответствующее ему значение могут быть получены одновременно посредством метода <code>items()</code>.

<syntaxhighlight lang="python">>>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}
>>> for k, v in knights.items():
...     print(k, v)
...
gallahad the pure
robin the brave</syntaxhighlight>

Функция <code>enumerate()</code> поможет пронумеровать элементы перебираемой в цикле последовательности:

<syntaxhighlight lang="python">>>> for i, v in enumerate(['tic', 'tac', 'toe']):
...     print(i, v)
...
0 tic
1 tac
2 toe</syntaxhighlight>

Для того, чтобы организовать цикл параллельно для двух или более последовательностей, элементы можно предварительно сгруппировать функцией <code>zip()</code><ref>''(Прим. перев.):''
<br /><br />
<code style="background-color: inherit !important;">>>> вопросы = ['имя', 'задание', 'любимый цвет']<br/>
>>> ответы = ['ланцелот', 'святой грааль', 'синий']<br/>
>>> '''для''' вопрос, ответ '''из''' ''застегнуть''(вопросы, ответы):<br/>
... &nbsp;&nbsp;&nbsp;&nbsp;'''вывести'''('Каков(о) ваш(е) {0}?  {1}.'.форматировать(вопрос, ответ))<br/>
...<br/>
Каков(о) ваш(е) имя?  ланцелот.<br/>
Каков(о) ваш(е) задание?  святой грааль.<br/>
Каков(о) ваш(е) любимый цвет?  синий.</code></ref>.

<syntaxhighlight lang="python">>>> questions = ['name', 'quest', 'favorite color']
>>> answers = ['lancelot', 'the holy grail', 'blue']
>>> for q, a in zip(questions, answers):
...     print('What is your {0}?  It is {1}.'.format(q, a))
...
What is your name?  It is lancelot.
What is your quest?  It is the holy grail.
What is your favorite color?  It is blue.</syntaxhighlight>

Изменить порядок следования последовательности на обратный поможет функция <code>reversed()</code>.

<syntaxhighlight lang="python">>>> for i in reversed(range(1, 10, 2)):
...     print(i)
...
9
7
5
3
1</syntaxhighlight>

Для организации цикла по отсортированной последовательности можно применить функцию <code>sorted()</code>, которая возвращает отсортированный список, оставляя исходный без изменений.

<syntaxhighlight lang="python">>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
>>> for f in sorted(set(basket)):
...     print(f)
...
apple
banana
orange
pear</syntaxhighlight>

=== Подробнее об условиях ===

Условия в операторах <code>if</code> и <code>while</code> могут содержать любые операции, а не только операции сравнения.

Операции сравнения <code>in</code> и <code>not in</code> проверяют, встречается значение в последовательности или нет. Операции <code>is</code> и <code>is not</code> проверяют, не являются ли два объекта на самом деле одним и тем же (это имеет смысл лишь для изменяемых объектов, таких как списки). Все операции сравнения имеют один и тот же приоритет, меньший чем у любых операций над числами.

Сравнения можно объединять в цепочки. Например, <code>a < b == c</code> проверяет, меньше ли <code>a</code> чем <code>b</code> и, сверх того, равны ли <code>b</code> и <code>c</code>.

Сравнения могут быть скомбинированы с использованием булевых операций <code>and</code> и <code>or</code>, а результат сравнения (или любого другого булева выражения) можно отрицать используя <code>not</code>. Эти операции имеют меньший приоритет, чем у операций сравнения; среди них у <code>not</code> высший приоритет, а у <code>or</code> — низший, поэтому <code>A and not B or C</code> эквивалентно <code>(A and (not B)) or C</code>. Как всегда, явно заданные скобки помогут выразить желаемый порядок выполнения операций.

Булевы операции <code>and</code> и <code>or</code> — это так называемые ''коротящие операции''<ref>''(Прим. перев.)'' ''short-circuit''{{ref-en}} — закоротить, обходить, идти обходными путями (для достижения цели), препятствовать</ref> (<tt>short-circuit operators</tt>): их операнды вычисляются слева направо и вычисление заканчивается как только результат становится определён (очевиден). Например, если <code>A</code> и <code>C</code> истинны, а <code>B</code> — ложно, в условии <code>A and B and C</code> выражение <code>C</code> не вычисляется. Когда ''коротящая операция'' используется не в контексте логической операции, она возвращает последний элемент, который был вычислен.

Можно присвоить результат сравнения, или другого булева выражения, переменной. Например,

<syntaxhighlight lang="python">>>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'
>>> non_null = string1 or string2 or string3
>>> non_null
'Trondheim'</syntaxhighlight>

Заметьте, что в Python (в отличие от C) присваивание не может использоваться внутри выражений. Программисты на C могут возмутиться по этому поводу, но на самом деле это позволяет избежать ряда проблем, обычного для программ на C: указания оператора присваивания (<code>=</code>) в выражении, вместо предполагавшегося сравнения (<code>==</code>).

=== Сравнение последовательностей и других типов ===

Объекты последовательностей можно сравнивать с другими объектами с тем же типом последовательности. Сравнение использует лексикографический порядок: сравниваются первые два элемента, и если они различны — результат сравнения определён; если они равны, сравниваются следующие два элемента и так далее до тех пор, пока одна из последовательностей не будет исчерпана. Если сравниваемые два элемента сами являются последовательностями одного типа, лексикографическое сравнение происходит в них рекурсивно. Если все элементы обеих последовательностей оказались равны, последовательности считаются равными. Если одна последовательность оказывается стартовой последовательностью другой, более короткая последовательность считается меньшей. Лексикографическое упорядочивание строк использует порядок в таблице Unicode для индивидуальных символов. Несколько примеров сравнений между однотипными последовательностями:

<syntaxhighlight lang="python">(1, 2, 3)              < (1, 2, 4)
[1, 2, 3]              < [1, 2, 4]
"Пайтон" < "Паскаль" < "Си" < "Си++"
(1, 2, 3, 4)           < (1, 2, 4)
(1, 2)                 < (1, 2, -1)
(1, 2, 3)             == (1.0, 2.0, 3.0)
(1, 2, ('aa', 'ab'), 4)   < (1, 2, ('abc', 'a'))</syntaxhighlight>

Обратите внимание, что сравнение объектов различных типов операциями <code><</code> или <code>></code> позволено, если объекты имеют соответствующие методы сравнения. Например, смешанные числовые типы сравниваются в соответствии с их численными значениями, так что <code>0</code> равен <code>0.0</code> и т. д. В противном случае интерпретатор, прервав процесс сортировки, возбудит исключение <code>TypeError</code>.

